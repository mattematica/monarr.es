
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Mathematical Structures &mdash; SDSU Sage Tutorial v1.1</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="SDSU Sage Tutorial v1.1" href="index.html" />
    <link rel="prev" title="Programming in Sage" href="sageprog.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sageprog.html" title="Programming in Sage"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">SDSU Sage Tutorial v1.1</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mathematical-structures">
<span id="id1"></span><h1>Mathematical Structures<a class="headerlink" href="#mathematical-structures" title="Permalink to this headline">¶</a></h1>
<p>The individual chapters in this part of the tutorial are relatively independent of one another.  You should be familiar with the chapter <a class="reference internal" href="sageprog.html#sage-objects"><em>Sage Objects</em></a> before reading material here.  The section <a class="reference internal" href="sageprog.html#list-comprehensions"><em>List Comprehensions (Loops in Lists)</em></a> is also useful.  Eventually, when you are ready for some real experimentation, you will want to read much of the chapter <a class="reference internal" href="sageprog.html#programming-tools"><em>Programming Tools</em></a>.   Many sections in this part are incomplete, and we welcome contributions and additions!</p>
<div class="section" id="integers-and-modular-arithmetic">
<span id="integers-modular-arithmetic"></span><h2>Integers and Modular Arithmetic<a class="headerlink" href="#integers-and-modular-arithmetic" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integers-modulo">
<span id="integers-modulo-n"></span><h3>Integers Modulo <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/><a class="headerlink" href="#integers-modulo" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>You should be familiar with <a class="reference internal" href="sageprog.html#universes-and-coercion"><em>Universes and Coercion</em></a> and <a class="reference internal" href="sageprog.html#variables"><em>Variables</em></a></div></blockquote>
<p id="index-0">In this section we cover how to construct <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/>, the ring of integers modulo
<img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>,  and do some basic computations.</p>
<p id="index-1">To construct <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> you use the <tt class="xref py py-class docutils literal"><span class="pre">Integers</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Integers(7)
Ring of integers modulo 7
sage: Integers(100)
Ring of integers modulo 100
</pre></div>
</div>
<p>We could do computations modulo an integer by repeatedly using the
<tt class="docutils literal"><span class="pre">%</span></tt> operator in all of our expressions, but by constructing the ring
explicitly we have access to a more natural method for doing
arithmetic.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R=Integers(13)
sage: a=R(6)
sage: b=R(5)
sage: a + b
11
sage: a*b
4
</pre></div>
</div>
<p id="index-2">And by explicitly coercing our numbers into the ring <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> we can compute some of the mathematical properties of the elements. Like their order, both multiplicative and additive, and whether or not the element is a unit.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a.additive_order()
13
sage: a.multiplicative_order()
12
sage: a.is_unit()
True
</pre></div>
</div>
<p id="index-3">The additive inverse of <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> is computed using <tt class="docutils literal"><span class="pre">-a</span></tt> and, if <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> is a unit, the multiplicative inverse is computed using <tt class="docutils literal"><span class="pre">a^(-1)</span></tt> or <tt class="docutils literal"><span class="pre">1/a</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: (-a)
7
sage: (a^(-1))
11
</pre></div>
</div>
<p>These inverses can be checked easily.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a + (-a)
0
sage: a*(a^(-1))
1
</pre></div>
</div>
<p>Recall that division in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> is really multiplication by an inverse.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R=Integers(24)
sage: R(4)/R(5)
20
sage: R(4)*R(5)^-1
20
sage: R(4/5)
20
</pre></div>
</div>
<p>Not all elements have an inverse, of course. If we try an invalid
division, Sage will complain</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R(5/4)
...
ZeroDivisionError: Inverse does not exist.
</pre></div>
</div>
<p>We have to be a little bit careful when we are doing this since we are asking Sage to coerce a rational number into the <img class="math" src="_images/math/e789173a1365dc9307caa5d87532d92563f00435.png" alt="\mathbb{Z}_{24}"/> This may cause some unexpected consequences since some reduction is done on rational numbers before the coercion. For an example, consider the following:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R(20).is_unit()
False
sage: R(16/20)
20
</pre></div>
</div>
<p>In  <img class="math" src="_images/math/e789173a1365dc9307caa5d87532d92563f00435.png" alt="\mathbb{Z}_{24}"/>,  <img class="math" src="_images/math/120b3bfdfb71bdbdeb6831dbafd4bec1d8a0cee1.png" alt="20"/> is not a unit, yet at first glance it would seem we divided by it. However, note the order of operations. First sage reduces <img class="math" src="_images/math/bfbc49cb18234f7813d4b45323a9729d9dc4575d.png" alt="16/20"/> to  <img class="math" src="_images/math/b3ddec95d0bace005025bf595c77478976a16f9a.png" alt="4/5"/>, and then coerces <img class="math" src="_images/math/b3ddec95d0bace005025bf595c77478976a16f9a.png" alt="4/5"/> into <img class="math" src="_images/math/e789173a1365dc9307caa5d87532d92563f00435.png" alt="\mathbb{Z}_{24}"/>. Since <img class="math" src="_images/math/516e8e69cb2e0cf19a092ecfaf763417e6f5fa3f.png" alt="5"/> is a unit in <img class="math" src="_images/math/e789173a1365dc9307caa5d87532d92563f00435.png" alt="\mathbb{Z}_{24}"/>, everything works out ok.</p>
<p id="index-4">We can also compute some properties of the ring itself.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R
Ring of integers modulo 24
sage: R.order()
24
sage: R.is_ring()
True
sage: R.is_integral_domain()
False
sage: R.is_field()
False
</pre></div>
</div>
<p id="index-5">Since this  ring is finite then we can have Sage list all of it&#8217;s elements.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R = Integers(13)
sage: R.list()
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</pre></div>
</div>
<p id="index-6"><tt class="docutils literal"><span class="pre">R</span></tt> in this example is a field, since <img class="math" src="_images/math/b78136ee77bf2901f904a04926f5aee40a8f0a7f.png" alt="13"/> is a prime number.  If our ring is not a field then the <em>units</em>  in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/>
form a group under multiplication. Sage can compute a list of generators of the <em>group of units</em> using it&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">unit_gens()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R = Integers(12)
sage: R.uni
R.unit_gens            R.unit_group_order
R.unit_group_exponent  R.unit_ideal
sage: R.unit_gens()
[7, 5]
</pre></div>
</div>
<p id="index-7">We can also compute the order of this subgroup.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.unit_group_order()
4
</pre></div>
</div>
<p>Unfortunately, Sage doesn&#8217;t seem to have a function which directly returns the units in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> as a group.  We can list the elements in a couple of different ways using the information above.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: (a,b) = R.unit_gens()
sage: a
7
sage: b
5
sage: [ (a^i)*(b^j) for i in range(2) for j in range(2) ]
[1, 5, 7, 11]
</pre></div>
</div>
<p id="index-8">We can also compute the list of units  by using a list comprehension.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: [ x for x in R if x.is_unit()]
[1, 5, 7, 11]
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Construct the ring of integers modulo <img class="math" src="_images/math/0076d7dc64a690d8c67dc724b72d0e5d71e620c8.png" alt="16"/> and answer the following:<ol class="loweralpha">
<li>Compute the multiplicative orders of <img class="math" src="_images/math/05742fd2840e5d6928c716d66edfec3b8d2d2017.png" alt="2,4,5,6,13"/> and <img class="math" src="_images/math/63ff20ee9dfddf8deba579b5b8c097c0f7c5e483.png" alt="15"/>?</li>
<li>Which of the elements listed above is a unit?</li>
<li>What are the generators for the group of units?</li>
<li>Compute a list of all of the elements in the group of units.</li>
</ol>
</li>
<li>Do all of the steps above again, but with the ring of integers modulo <img class="math" src="_images/math/69b2b4dbe02a4b8f6ad4185ebb232189f873c662.png" alt="17"/>.</li>
<li>Use an exhaustive search method to write a function which determines if a is a unit modulo n.</li>
<li>For <img class="math" src="_images/math/a377c80ad7fc41b228abc57b2dffd9fabc38a00f.png" alt="n = 13, 15"/> and <img class="math" src="_images/math/dd4dd2fa4e02177de2d3b5241b1c5f90316bc4cb.png" alt="21"/> determine which of <img class="math" src="_images/math/05c18c06b4fab6889ef320faa7784c863c36d35f.png" alt="3,4"/> and <img class="math" src="_images/math/516e8e69cb2e0cf19a092ecfaf763417e6f5fa3f.png" alt="5"/> are units in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/>. When you find a unit, determine its inverse and compare this to the output of <img class="math" src="_images/math/b46446ef0640b0d3553b0c9b8dd7c0a5bdcc9b37.png" alt="xgcd(a,n)"/>. Try to explain this relationship.</li>
<li>Use Sage to determine whether the following Rings are fields. For each  example, describe the unit group using generators and relations.<ol class="loweralpha">
<li><img class="math" src="_images/math/0612b062d88094a23159481ebf0964f31770ee59.png" alt="\mathbb{Z}_{1091}"/></li>
<li><img class="math" src="_images/math/5112f4351f67f59113b03ff9229ddb623b329571.png" alt="\mathbb{Z}_{1047}"/></li>
<li><img class="math" src="_images/math/f408185470a4397f5fcf8b6bb6b2a8205b599006.png" alt="\mathbb{Z}_{1037}"/></li>
<li><img class="math" src="_images/math/55982b7b1df4f956a6e640abc645abaaab87ad6f.png" alt="\mathbb{Z}_{1087}"/></li>
</ol>
</li>
</ol>
</div></blockquote>
<span class="target" id="linear-congruences"></span></div>
<div class="section" id="solving-congruences">
<span id="index-9"></span><h3>Solving Congruences<a class="headerlink" href="#solving-congruences" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>You should be familiar with <a class="reference internal" href="#integers-modulo-n"><em>Integers Modulo </em></a> and <a class="reference internal" href="sageprog.html#list-comprehensions"><em>List Comprehensions (Loops in Lists)</em></a></div></blockquote>
<p>A linear congruence is an equation of the form <img class="math" src="_images/math/23299cf9de1e2a7520c1011b99bacf11a8a1605d.png" alt="ax=b"/> in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/>. One way to see if there is a solution to such a problem is an exhaustive search. For example, to determine if there exists a solution to <img class="math" src="_images/math/3a2c9788ee50a897d4315cbb35f1ffe6fdc96eb4.png" alt="9x = 6"/> we can do the following:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R=Integers(21)
sage: a=R(9)
sage: 6 in [ a*x for x in R ]
True
</pre></div>
</div>
<p>Notice that the above tells us only that there exists at least one solution to the equation <img class="math" src="_images/math/7925aefedbf0cf847de7714955edc02e2ae75407.png" alt="9x= 6"/> in <img class="math" src="_images/math/9938331b65948dc2e052075ffe2f97b3dac0551f.png" alt="\mathbb{Z}_{21}"/>. We can construct the list of these solutions by using the following list comprehension.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: [ x for x in R if R(9)*x == R(6)]
[3, 10, 17]
</pre></div>
</div>
<p>We can  determine when a solution does not exist in a similar fashion.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: [ x for x in R if R(9)*x == R(2) ]
[]
</pre></div>
</div>
<p id="index-10">We can also use the <tt class="xref py py-func docutils literal"><span class="pre">solve_mod()</span></tt> function to compute the same results.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: solve_mod( 9*x == 6, 21)
[(3,), (10,), (17,)]
sage: solve_mod( 9*x == 2, 21)
[]
</pre></div>
</div>
<p><tt class="xref py py-func docutils literal"><span class="pre">solve_mod()</span></tt> can handle linear congruences of more than one variable.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: solve_mod( 9*x + 7*y == 2, 21)
[(15, 14), (15, 8), (15, 2), (15, 17), (15, 11), (15, 5), (15, 20), (1, 14), (1, 8), (1, 2), (1, 17), (1, 11), (1, 5), (1, 20), (8, 14), (8, 8), (8, 2), (8, 17), (8, 11), (8, 5), (8, 20)]
</pre></div>
</div>
<p>The solutions are in the form <img class="math" src="_images/math/3a0b416686615b9caa50bfa095438471b070e39c.png" alt="\left(x,y\right)"/>, where the
variables are listed in the order in which they appear in the equations.</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">solve_mod()</span></tt> can  solve systems of linear congruences.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: solve_mod( [9*x + 2*y == 2, 3*x + 2*y == 11   ], 21)
[(9, 13), (16, 13), (2, 13)]
</pre></div>
</div>
<p>As with  the <tt class="xref py py-func docutils literal"><span class="pre">solve()</span></tt> command, computations can be slow when working with systems that have a lot of variables and/or
equations. For these systems the linear algebra capabilities are
recommended.</p>
<p>We can also compute the solutions for non-linear congruences
using <tt class="xref py py-func docutils literal"><span class="pre">solve_mod()</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: solve_mod(x^2 + y^2 == 1, 7)
[(0, 1), (0, 6), (1, 0), (2, 2), (2, 5), (5, 2), (5, 5), (6, 0)]
sage: solve_mod([x^2 + y^2 == 1, x^2 - y == 2], 7)
[(2, 2), (5, 2)]
</pre></div>
</div>
<p id="index-11">Finally, Sage can compute the simulatenous solution of linear
congruences with different modulii under certain circumstances. This
is done using the <em>Chineses Remainder Theorem</em>, and is implemented in
the <tt class="xref py py-func docutils literal"><span class="pre">crt()</span></tt> command. For example, the following computes the
smallest nonnegative integer, <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> that is congruent to <img class="math" src="_images/math/0a4cb1c52924e29bb015d77cbdc25de07f2be06b.png" alt="3 \bmod 8"/>, <img class="math" src="_images/math/8556badd7abb0b517a47bb1c04557719ada6b0f4.png" alt="4 \bmod 9"/>,
and <img class="math" src="_images/math/973d1c8ad863420da9fad6ff7fb540eb12bfaef4.png" alt="5 \bmod 25"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: crt([3,4,5],[8,9,25])
355
</pre></div>
</div>
<p>We can check the validity of this solution using the <tt class="xref py py-func docutils literal"><span class="pre">mod()</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: mod(355,8)
3
sage: mod(355,9)
4
sage: mod(355,25)
5
</pre></div>
</div>
<p>The set of all integer solutions is those
integers congruent to <img class="math" src="_images/math/486c40b112e5464a64d65a186d0fbbd707ac2604.png" alt="355"/>  modulo <img class="math" src="_images/math/fbe8c3a78eaa318ab5e2a449a426c4de9e0062cc.png" alt="8*9*25=1800"/>.</p>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Find all solutions to the following congruences over <img class="math" src="_images/math/fb4ae7e159b6d64408e91ca7b9f683511626d238.png" alt="\mathbb{Z}_{42}"/>.<ol class="loweralpha">
<li><img class="math" src="_images/math/a2f68275092edc12c20ff4262fa635a1de33e2b0.png" alt="41x = 2"/></li>
<li><img class="math" src="_images/math/b133702cdb53f3fa275045cb4c9b987dff28f544.png" alt="5x = 13"/></li>
<li><img class="math" src="_images/math/1258d9506a6f95e1e70726e7681e72170e737429.png" alt="6x = 0"/></li>
<li><img class="math" src="_images/math/58c5c804bfb1c01e37577afee0867d41f589eafa.png" alt="6x = 12"/></li>
<li><img class="math" src="_images/math/18d20499b38bda9ea42d13e4d0155df770c41e5b.png" alt="6x = 18"/></li>
<li><img class="math" src="_images/math/0812f0f3410b80c05534c58f1b9e44376b0a4285.png" alt="37x = 21"/></li>
</ol>
</li>
<li>Above you computed the solution sets for the congruences  <img class="math" src="_images/math/71c48e9a28a23823156334dbab3b9a6f6302f8c0.png" alt="6x =0"/>, <img class="math" src="_images/math/58c5c804bfb1c01e37577afee0867d41f589eafa.png" alt="6x = 12"/> and <img class="math" src="_images/math/18d20499b38bda9ea42d13e4d0155df770c41e5b.png" alt="6x = 18"/>. What are the    similarities?  What are the differences? Can you use these results  to say something in general about the structure of the set    <img class="math" src="_images/math/d1e4c9bb85d9f08cded1f5194e1a53c197e51750.png" alt="{\left\{ 6x \mid x \in \mathbb{Z}_{42} \right\} }"/> ?</li>
<li>Use the <tt class="xref py py-func docutils literal"><span class="pre">solve_mod()</span></tt> command find all of the solutions to the following congruences modulo <img class="math" src="_images/math/875aef0345957cee6630bb6d0dbbe1ee39f34b87.png" alt="36"/>.<ol class="loweralpha">
<li><img class="math" src="_images/math/290460fbb9654b1bef2d720b3e2b973a80c2779a.png" alt="3x = 21"/></li>
<li><img class="math" src="_images/math/f15f777cc51b10e29604f127703197ee18b71aad.png" alt="7x = 13"/></li>
<li><img class="math" src="_images/math/8b3904e8e16ee78dbe6301faf7812ae3c3873c4b.png" alt="23x = 32"/></li>
<li><img class="math" src="_images/math/e2145061b2f45dbbe4df3328e7d7a0f4ac15df55.png" alt="8x = 14"/></li>
</ol>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mini-topic-euclidean-algorithm">
<span id="euclidean-algorithm"></span><h3>Mini-Topic: Euclidean Algorithm<a class="headerlink" href="#mini-topic-euclidean-algorithm" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>You should be familiar with <a class="reference internal" href="sagecalc.html#division-and-factoring"><em>Integer Division and Factoring</em></a>, <a class="reference internal" href="sageprog.html#variables"><em>Variables</em></a>, <a class="reference internal" href="sageprog.html#external-files-and-sessions"><em>External Files and Sessions</em></a>, and <a class="reference internal" href="sageprog.html#while-loops"><em>While loops</em></a></div></blockquote>
<p id="index-12">Recall that for <img class="math" src="_images/math/dc80f38b81d70929fe8fe962c7bbcffa3fedac53.png" alt="a,b \in \mathbb{Z}"/> with <img class="math" src="_images/math/0215e154bbd0b7008ea4e3c89fcfa81252d64f5d.png" alt="b \neq 0"/>, there always exists unique <img class="math" src="_images/math/d13a402293a44c38d8aad1006ffa1a26668f791c.png" alt="q,r \in \mathbb{Z}"/> such that <img class="math" src="_images/math/03d83b47f4046ebb7f9ac9965047c195c013f4bc.png" alt="a=bq+r"/> with <img class="math" src="_images/math/c9027fa413eec2fe57a0e9a50bb438e44f1fa6c5.png" alt="0 \leq r&lt; b"/>. With that in mind, we will use Sage to calculate the <em>gcd</em> of two integers using the <em>Euclidean Algorithm</em>. The following code is an implementation of the Euclidean Algorithm in Sage.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Begin euclid.sage</span>
<span class="n">r</span><span class="o">=</span><span class="n">a</span><span class="o">%</span><span class="n">b</span>
<span class="k">print</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
<span class="k">while</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span> <span class="n">b</span><span class="o">=</span><span class="n">r</span>
        <span class="n">r</span><span class="o">=</span><span class="n">a</span><span class="o">%</span><span class="n">b</span>
        <span class="k">print</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
<span class="c"># End euclid.sage</span>
</pre></div>
</div>
<p>If you create a file <tt class="docutils literal"><span class="pre">euclid.sage</span></tt> containing the text above, then the output after loading the file is:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a=15; b=4
sage: load euclid.sage
(15, 4, 3) (4, 3, 1) (3, 1, 0)
sage: a=15; b=5
sage: load euclid.sage
(15, 5, 0)
</pre></div>
</div>
<p>In the first case, we see that the <tt class="docutils literal"><span class="pre">gcd</span></tt> was <img class="math" src="_images/math/123e375e88da91240024aaf085abee194c4a2d06.png" alt="1"/>, while in the second the <tt class="docutils literal"><span class="pre">gcd</span></tt> was <img class="math" src="_images/math/516e8e69cb2e0cf19a092ecfaf763417e6f5fa3f.png" alt="5"/>.</p>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Revise the loop in the <tt class="docutils literal"><span class="pre">euclid.sage</span></tt> so that only the gcd and the total number of divisions (i.e. the number of steps through the algorithm) are printed. Compare the speed of this version of the algorithm with the built-in Sage function <tt class="xref py py-func docutils literal"><span class="pre">gcd()</span></tt> by using both functions on large integers.</li>
<li>Write your own <em>Extended Euclidean Algorithm</em> by revising the loop in <tt class="docutils literal"><span class="pre">euclid.sage</span></tt>.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="groups">
<span id="id2"></span><h2>Groups<a class="headerlink" href="#groups" title="Permalink to this headline">¶</a></h2>
<p id="index-13">There are three major types of groups implemented in sage,
<tt class="xref py py-func docutils literal"><span class="pre">PermutationGroup()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">MatrixGroup()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">AbelianGroup()</span></tt>.
We will work with permutation groups first and cover most of the methods that
are applied to them.  Many of these methods are applicable to
arbitrary groups, so the other sections will  be somewhat briefer and will
focus on methods particular to those structures.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://buzzard.ups.edu/sage/sage-group-theory-primer.pdf">Group Theory and Sage: A Primer</a>
by Rob Beezer</p>
</div>
<div class="section" id="symmetric-groups">
<span id="id3"></span><h3>Symmetric  Groups<a class="headerlink" href="#symmetric-groups" title="Permalink to this headline">¶</a></h3>
<p id="index-14">The Symmetric Group <img class="math" src="_images/math/f39351eac08bf9287632cba622eedb8e7e8c56ad.png" alt="S_n"/> is the group of all permutations on <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> elements.  First we will construct the symmetric group on <img class="math" src="_images/math/fc0d270ca0ef95a79c061746cc21ad427cc8cb4c.png" alt="\{ 1, 2, 3, 4 ,5 \}"/> which is done by using the <tt class="xref py py-class docutils literal"><span class="pre">SymmetricGroup</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S5 = SymmetricGroup(5)
S5 Symmetric group of order 5! as a permutation group
</pre></div>
</div>
<p>Once the group has been constructed we can check the number of elements, which is <img class="math" src="_images/math/890ae82b4e5f23475c436e6b138d9a0a719c41c4.png" alt="5!"/>, and  list them all.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S5.cardinality()
 120
sage: S5.list()
 [(), (4,5), (3,4), (3,4,5), (3,5,4), (3,5), (2,3), (2,3)(4,5), (2,3,4), (2,3,4,5), (2,3,5,4), (2,3,5), (2,4,3), (2,4,5,3), (2,4), (2,4,5), (2,4)(3,5), (2,4,3,5), (2,5,4,3), (2,5,3), (2,5,4), (2,5), (2,5,3,4), (2,5)(3,4), (1,2), (1,2)(4,5), (1,2)(3,4), (1,2)(3,4,5), (1,2)(3,5,4), (1,2)(3,5), (1,2,3), (1,2,3)(4,5), (1,2,3,4), (1,2,3,4,5), (1,2,3,5,4), (1,2,3,5), (1,2,4,3), (1,2,4,5,3), (1,2,4), (1,2,4,5), (1,2,4)(3,5), (1,2,4,3,5), (1,2,5,4,3), (1,2,5,3), (1,2,5,4), (1,2,5), (1,2,5,3,4), (1,2,5)(3,4), (1,3,2), (1,3,2)(4,5), (1,3,4,2), (1,3,4,5,2), (1,3,5,4,2), (1,3,5,2), (1,3), (1,3)(4,5), (1,3,4), (1,3,4,5), (1,3,5,4), (1,3,5), (1,3)(2,4), (1,3)(2,4,5), (1,3,2,4), (1,3,2,4,5), (1,3,5,2,4), (1,3,5)(2,4), (1,3)(2,5,4), (1,3)(2,5), (1,3,2,5,4), (1,3,2,5), (1,3,4)(2,5), (1,3,4,2,5), (1,4,3,2), (1,4,5,3,2), (1,4,2), (1,4,5,2), (1,4,2)(3,5), (1,4,3,5,2), (1,4,3), (1,4,5,3), (1,4), (1,4,5), (1,4)(3,5), (1,4,3,5), (1,4,2,3), (1,4,5,2,3), (1,4)(2,3), (1,4,5)(2,3), (1,4)(2,3,5), (1,4,2,3,5), (1,4,2,5,3), (1,4,3)(2,5), (1,4)(2,5,3), (1,4,3,2,5), (1,4)(2,5), (1,4,2,5), (1,5,4,3,2), (1,5,3,2), (1,5,4,2), (1,5,2), (1,5,3,4,2), (1,5,2)(3,4), (1,5,4,3), (1,5,3), (1,5,4), (1,5), (1,5,3,4), (1,5)(3,4), (1,5,4,2,3), (1,5,2,3), (1,5,4)(2,3), (1,5)(2,3), (1,5,2,3,4), (1,5)(2,3,4), (1,5,3)(2,4), (1,5,2,4,3), (1,5,3,2,4), (1,5)(2,4,3), (1,5,2,4), (1,5)(2,4)]
</pre></div>
</div>
<p>As you can see from the list, in Sage a permutation is written in <em>cycle notation</em>.  Note that the empty parenthesis <cite>()</cite> is used to  represent the identity permutation.  We create the identity permutation and  a randomly chosen element as follows.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: id = S5.identity()
()
sage: S5.random_element()
(1,2)(3,4)
sage: r=  S5.random_element(), r
(1,3,4)(2,5)
</pre></div>
</div>
<p>As you can see, subsequent calls for a random element give a  new element each time.  We can also express the element <img class="math" src="_images/math/2ede365ad144ab396916ec60458da03860803078.png" alt="r"/> as a
function by listing the images of <img class="math" src="_images/math/8e3d5a8c1ecc09b49bf9c9b3ef1df08044369845.png" alt="1,2,3,4,5"/> in order.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: r.list()
[3,5,4,1,2]
</pre></div>
</div>
<p>We can construct a specific element in <img class="math" src="_images/math/045df5848a53a31212bd3a9621f96fc54dca04b0.png" alt="S_5"/> by coercing a permutation, written in <em>cycle notation</em>, into <img class="math" src="_images/math/649349c634a3e787a9ff3f6a723e8fc269c77792.png" alt="S5"/>. We must
enclose the  product of cycles in quotations for Sage to parse the input correctly.</p>
<div class="highlight-python"><div class="highlight"><pre>sage:  r = S5(&#39;(1,3)(2,4)&#39;); r
(1,3)(2,4)
sage:  s = S5(&#39;(1,4,3,2)&#39;); s
(1,4,3,2)
</pre></div>
</div>
<p>We may also construct an element <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> using the list of images that it has as a function.</p>
<div class="highlight-python"><div class="highlight"><pre>sage:  t = S5([1,5,4,3,2]); t
(2,5)(3,4)
</pre></div>
</div>
<p>The product of cycles is taken from <em>left-to-right</em> and is, of
course, not commutative.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: s*t
(1,4,2,3)
sage: t*s
(1,2,4,3)
sage: id*s
</pre></div>
</div>
<p id="index-15">Let&#8217;s compute the order of an element by using the object&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">order()</span></tt> method and check this directly.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: r.order()
2
sage: r*r
()
sage: s.order()
4
sage: s*s
(1,3)(2,4)
sage: s*s*s*s
()
</pre></div>
</div>
<p>The <em>exponent</em> of a group is the least common multiple of the orders of the elements.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S5.exponent()
  60
</pre></div>
</div>
<p id="index-16">The <tt class="xref py py-meth docutils literal"><span class="pre">sign()</span></tt> method  is used to compute the sign of a permutation,
indicating whether it can be written as the product of an even or an odd number
of permutations.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S5(&#39;(2,3,4)&#39;).sign()
1
sage: S5(&#39;(4,5)&#39;).sign()
-1
</pre></div>
</div>
<p id="index-17">Each symmetric group <img class="math" src="_images/math/f39351eac08bf9287632cba622eedb8e7e8c56ad.png" alt="S_n"/> is a subgroup of <img class="math" src="_images/math/1d0b4098833c85aab5336b204355fb42447a694e.png" alt="S_{n+1}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S4 = SymmetricGroup(4)
sage: S4.is_subgroup(S5)
True
</pre></div>
</div>
<p>You can construct the subgroup generated by a list of elements by
using the <tt class="xref py py-meth docutils literal"><span class="pre">subgroup()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H = S5.subgroup([r,s])
sage: H
Subgroup of SymmetricGroup(5) generated by [(1,3)(2,4), (1,4,3,2)]
sage: H.list()
[(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]
</pre></div>
</div>
<p id="index-18">We can test to see if the subgroup that we have just created has
certain properties by using the appropriate methods.
typing <tt class="xref py py-meth docutils literal"><span class="pre">H.is()</span></tt> &lt;tab&gt; will give a list of several properties to test.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H.is_abelian()
True
sage: H.is_cyclic()
True
</pre></div>
</div>
<p>The elements originally used to  generate a subgroup are obtained with the <tt class="xref py py-meth docutils literal"><span class="pre">gens()</span></tt> method.
Sage can&#8217;t guarantee a minimal generating set, but <tt class="xref py py-meth docutils literal"><span class="pre">gens_small()</span></tt>
makes an attempt.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H.gens()
[(1,3)(2,4), (1,4,3,2)]
sage: H.gens_small()
[(1,4,3,2)]
</pre></div>
</div>
<p id="index-19">A useful tool for examining the structure of a group is the
multiplication table, often called the <em>Cayley Table</em>.
Invoke the group&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">cayley_table()</span></tt> method
(also called <tt class="xref py py-meth docutils literal"><span class="pre">multiplication_table()</span></tt>). The default uses
letters to represent the group elements (in the order they appear
using <tt class="xref py py-meth docutils literal"><span class="pre">list()</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S3 = SymmetricGroup(3)
sage: S3.cayley_table()
*  a b c d e f
+-----------
a| a b c d e f
b| b a d c f e
c| c e a f b d
d| d f b e a c
e| e c f a d b
f| f d e b c a
sage: S3.list()
[(), (2,3), (1,2), (1,2,3), (1,3,2), (1,3)]
</pre></div>
</div>
<p>We can also use the elements themselves, or
give them names.  Here we assign name based on the symmetries of a
triangle: <tt class="xref py py-meth docutils literal"><span class="pre">u_i()</span></tt> for reflections through the axis containing
vertex <tt class="xref py py-meth docutils literal"><span class="pre">i()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">r^1,</span> <span class="pre">r^2()</span></tt> for the rotations.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S3.cayley_table(names=&#39;elements&#39;)
*       |      ()   (2,3)   (1,2) (1,2,3) (1,3,2)   (1,3)
-------------------------------------------------
()      |      ()   (2,3)   (1,2) (1,2,3) (1,3,2)   (1,3)
(2,3)   |   (2,3)      () (1,2,3)   (1,2)   (1,3) (1,3,2)
(1,2)   |   (1,2) (1,3,2)      ()   (1,3)   (2,3) (1,2,3)
(1,2,3) | (1,2,3)   (1,3)   (2,3) (1,3,2)      ()   (1,2)
(1,3,2) | (1,3,2)   (1,2)   (1,3)      () (1,2,3)   (2,3)
(1,3)   |   (1,3) (1,2,3) (1,3,2)   (2,3)   (1,2)      ()


sage: S3.cayley_table(names=[&#39;id&#39;,&#39;u1&#39;,&#39;u3&#39;,&#39;r1&#39;,&#39;r2&#39;,&#39;u2&#39;])
*  id u1 u3 r1 r2 u2
+------------------
id| id u1 u3 r1 r2 u2
u1| u1 id r1 u3 u2 r2
u3| u3 r2 id u2 u1 r1
r1| r1 u2 u1 r2 id u3
r2| r2 u3 u2 id r1 u1
u2| u2 r1 r2 u1 u3 id
</pre></div>
</div>
<div class="section" id="general-permutation-groups">
<span id="permutation-groups"></span><h4>General Permutation Groups<a class="headerlink" href="#general-permutation-groups" title="Permalink to this headline">¶</a></h4>
<p id="index-20">A permutation group is a subgroup of some symmetric group.
We can construct a permutation group directly, without constructing
the whole symmetric group, by giving a list of permutations to the <tt class="xref py py-class docutils literal"><span class="pre">PermutationGroup</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: r = &#39;(1,3)(2,4)(5)&#39;
sage: s = &#39;(1,3,2)&#39;
sage: K = PermutationGroup([r,s])
sage: K
Permutation Group with generators [(1,3,2), (1,3)(2,4)]
sage: K.order()
12
</pre></div>
</div>
<p>Several important permutation groups can also be constructed directly.
Here are the simplest.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K= KleinFourGroup(); K
The Klein 4 group of order 4, as a permutation group
sage: K.list()
[(), (3,4), (1,2), (1,2)(3,4)]
sage: Q= QuaternionGroup(); Q.list()
[(), (1,2,3,4)(5,6,7,8), (1,3)(2,4)(5,7)(6,8),
(1,4,3,2)(5,8,7,6), (1,5,3,7)(2,8,4,6), (1,6,3,8)(2,5,4,7),
(1,7,3,5)(2,6,4,8), (1,8,3,6)(2,7,4,5)]
sage: [x.order() for x in Q]
[1, 4, 2, 4, 4, 4, 4, 4]
</pre></div>
</div>
<p id="index-21">There are  several families  of permutation groups. The
<tt class="xref py py-class docutils literal"><span class="pre">CyclicPermutationGroup</span></tt> in <img class="math" src="_images/math/f39351eac08bf9287632cba622eedb8e7e8c56ad.png" alt="S_n"/> is generated by the cycle <img class="math" src="_images/math/2d5aab661d8f3063770b6675bd0cab2388e6d1f5.png" alt="(1,2,\dots,n)"/>. The <tt class="xref py py-class docutils literal"><span class="pre">DihedralGroup</span></tt>
is <img class="math" src="_images/math/f39351eac08bf9287632cba622eedb8e7e8c56ad.png" alt="S_n"/> is the symmetries of a regular <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> -gon with the
vertices enumerated clockwise from 1 to <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>.  It is generated by
the rotation <img class="math" src="_images/math/2d5aab661d8f3063770b6675bd0cab2388e6d1f5.png" alt="(1,2,\dots,n)"/> and a reflection.  Use the
<tt class="xref py py-meth docutils literal"><span class="pre">gens()</span></tt> to see which reflection is used.
The collection of all even permutations&#8212;permutations with positive
sign&#8212;is a subgroup of <img class="math" src="_images/math/045df5848a53a31212bd3a9621f96fc54dca04b0.png" alt="S_5"/>  obtained by the command <tt class="xref py py-class docutils literal"><span class="pre">AlternatingGroup</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = CyclicPermutationGroup(4); C
Cyclic group of order 4 as a permutation group
sage: C.list()
[(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]
sage: D = DihedralGroup(4); D
Dihedral group of order 8 as a permutation group
sage: D.list()
[(), (2,4), (1,2)(3,4), (1,2,3,4), (1,3), (1,3)(2,4), (1,4,3,2),
(1,4)(2,3)]
sage: D.gens()
[(1,2,3,4), (1,4)(2,3)]
sage: A = AlternatingGroup(4); A
Alternating group of order 4!/2 as a permutation group
sage: A.cardinality()
12
</pre></div>
</div>
<p>Another builtin group is  the <tt class="xref py py-class docutils literal"><span class="pre">DiCyclicGroup</span></tt>  (see
<a class="reference external" href="http://groupprops.subwiki.org/wiki/Dicyclic_group">the Group Properties article</a>).
Let&#8217;s  check that the <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/> is not  isomorphic to the dicyclic
group with the same number of elements.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: B = DiCyclicGroup(3); B
Diyclic group of order 12 as a permutation group
sage: B.list()
[(), (5,6,7), (5,7,6), (1,2)(3,4), (1,2)(3,4)(5,6,7), (1,2)(3,4)(5,7,6), (1,3,2,4)(6,7), (1,3,2,4)(5,6), (1,3,2,4)(5,7), (1,4,2,3)(6,7), (1,4,2,3)(5,6), (1,4,2,3)(5,7)]
sage: A.is_isomorphic(B)
False
</pre></div>
</div>
<p>With any permutation group we may compute its cardinality, list its elements, compute the order of elements, etc.
By using python&#8217;s <em>list comprehensions</em> (see <a class="reference internal" href="sageprog.html#lists"><em>Lists</em></a>) we can
create a list of elements with certain properties. In this case we can
construct the list of all elements or order 2.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S5 = SymmetricGroup(5)
sage: T = [s for s in S5  if s.order() == 2 ];  T
 [(4,5), (3,4), (3,5), (2,3), (2,3)(4,5), (2,4), (2,4)(3,5), (2,5), (2,5)(3,4), (1,2), (1,2)(4,5), (1,2)(3,4), (1,2)(3,5), (1,3), (1,3)(4,5), (1,3)(2,4), (1,3)(2,5), (1,4), (1,4)(3,5), (1,4)(2,3), (1,4)(2,5), (1,5), (1,5)(3,4), (1,5)(2,3), (1,5)(2,4)]
</pre></div>
</div>
<p id="index-22">Next we will construct  a permutation group  <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> and list
it&#8217;s members. This group <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> has different elements from <tt class="xref py py-class docutils literal"><span class="pre">DihedralGroup(5)</span></tt>,
but  is isomorphic to it.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H= PermutationGroup([&#39;(1,5),(3,4)&#39;, &#39;(1,2,5,4,3)&#39;]); H
Subgroup of SymmetricGroup(5) generated by [(1,2,5,4,3), (1,5)(3,4)]
sage: H.list()
[(), (2,3)(4,5), (1,2)(3,5), (1,2,5,4,3), (1,3,4,5,2), (1,3)(2,4), (1,4,2,3,5), (1,4)(2,5), (1,5)(3,4), (1,5,3,2,4)]
sage: H.order()
10
sage: D = DihedralGroup(5)
sage: D
Dihedral group of order 10 as a permutation group
sage: D.list()
[(), (2,5)(3,4), (1,2)(3,5), (1,2,3,4,5), (1,3)(4,5), (1,3,5,2,4), (1,4)(2,3), (1,4,2,5,3), (1,5,4,3,2), (1,5)(2,4)]
sage: H == D
False
sage: H.is_isomorphic(D)
True
</pre></div>
</div>
<p id="index-23">As with the symmetric group, we can pass a list of
group elements to the method <tt class="xref py py-meth docutils literal"><span class="pre">subgroup()</span></tt> to create a subgroup of
any permutation group.</p>
<p>The list of all subgroups of a permutation group is obtained by the
<tt class="xref py py-meth docutils literal"><span class="pre">subgroups()</span></tt> method.  It returns a list whose 0th element is the
trivial subgroup.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: D = DihedralGroup(4)
sage: L = D.subgroups(); L
[Permutation Group with generators [()], Permutation Group with generators [(1,3)(2,4)], Permutation Group with generators [(2,4)], Permutation Group with generators [(1,3)], Permutation Group with generators [(1,2)(3,4)], Permutation Group with generators [(1,4)(2,3)], Permutation Group with generators [(2,4), (1,3)(2,4)], Permutation Group with generators [(1,2,3,4), (1,3)(2,4)], Permutation Group with generators [(1,2)(3,4), (1,3)(2,4)], Permutation Group with generators [(2,4), (1,2,3,4), (1,3)(2,4)]]
</pre></div>
</div>
<p>The join of two subgroups <img class="math" src="_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> and <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/>, is the group
generated by the union of the two subgroups. We get the union of <img class="math" src="_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> and <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> by &#8220;adding&#8221; the
respective lists.
In the example below, we see that the cyclic permutation group
generated by <img class="math" src="_images/math/671257824f996811e9ae4e8ad93d2440885a2bcc.png" alt="(1,2,3,4,5)"/> and the Klein four group generate the
whole symmetric group <img class="math" src="_images/math/045df5848a53a31212bd3a9621f96fc54dca04b0.png" alt="S_5"/>. Notice that the Klein four group is
a subgroup of <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/>, which itself is a subgroup of <img class="math" src="_images/math/045df5848a53a31212bd3a9621f96fc54dca04b0.png" alt="S_5"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K = KleinFourGroup(); K.list()
[(), (3,4), (1,2), (1,2)(3,4)]
sage: C = CyclicPermutationGroup(5)
sage: CjK = PermutationGroup(C.list()+K.list() )
Permutation Group with generators [(), (3,4), (1,2), (1,2)(3,4), (1,2,3,4,5), (1,3,5,2,4), (1,4,2,5,3), (1,5,4,3,2)]
sage: CjK.gens_small(); CjK.cardinality()
[(1,2)(3,5,4), (1,4,5,3)]
120
sage: CjK == SymmetricGroup(5)
True
</pre></div>
</div>
<p>The centralizer of an element <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> (the
subgroup of elements that commute with <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/>) and the center of a
group are constructed in the way you&#8217;d expect.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: D.center()
Subgroup of (Dihedral group of order 8 as a permutation group) generated by [(1,3)(2,4)]
sage: D.centralizer(D(&#39;(1,3)(2,4)&#39;))
Subgroup of (Dihedral group of order 8 as a permutation group) generated by [(1,2,3,4), (1,4)(2,3)]
</pre></div>
</div>
</div>
<div class="section" id="quotients-of-permutation-groups">
<span id="index-24"></span><h4>Quotients of Permutation Groups<a class="headerlink" href="#quotients-of-permutation-groups" title="Permalink to this headline">¶</a></h4>
<p>In this section we explore normal subgroups and the quotient of a
group by a normal subgroup.  First we consider cosets and conjugation.</p>
<p>The alternating group <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/> has a subgroup isomorphic to the
Klein four group that is normal.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A4 = AlternatingGroup(4)
sage: g1 = A4(&#39;(1,4)(3,2)&#39;) ; g2 = A4(&#39;(2,4)(1,3)&#39;)
sage: H = A4.subgroup([g1,g2]);
sage: H.is_normal(A4); H.is_isomorphic(KleinFourGroup())
True
True
</pre></div>
</div>
<p>Let&#8217;s compare the right and left cosets of <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> in <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Hr = A4.cosets(H, side = &#39;right&#39;)
sage: Hl = A4.cosets(H, side = &#39;left&#39;)
sage: Hr; Hl
[[(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)], [(2,3,4), (1,3,2), (1,4,3), (1,2,4)], [(2,4,3), (1,4,2), (1,2,3), (1,3,4)]]
[[(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)], [(2,3,4), (1,2,4), (1,3,2), (1,4,3)], [(2,4,3), (1,2,3), (1,3,4), (1,4,2)]]
sage: Hr == Hl
False
</pre></div>
</div>
<p>We can see they are equal, but sage is comparing each coset as lists, and
notes that the elements of the last two  cosets are not listed in the same order.
To rectify this, use <tt class="xref py py-meth docutils literal"><span class="pre">sorted()</span></tt> to remind sage to order each coset.  We are fortunate with this example
that the cosets themselves are listed in the same order.  Otherwise we would have to apply <tt class="xref py py-meth docutils literal"><span class="pre">sorted()</span></tt> to the two lists of cosets.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Hr_sorted = [sorted(S) for S in Hr]
sage: Hl_sorted = [sorted(S) for S in Hl]
sage: Hr_sorted == Hl_sorted
True
</pre></div>
</div>
<p>The conjugate by <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/>  of an element <img class="math" src="_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> is the element <img class="math" src="_images/math/12754cc187f080cd01db817bd50e1750bc978b1d.png" alt="a^{-1}ga"/>.
The set of all conjugates of <img class="math" src="_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> as  <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> varies is the conjugacy class of <img class="math" src="_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/>.
Below, we create a 3-cycle and compute its conjugacy class  in <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> and then in <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/>.  This shows that two elements may be conjugate in <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> but not in <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S4 = SymmetricGroup(4)
sage: A4 = AlternatingGroup(4)
sage: g = S4(&#39;(1,3,4)&#39;)
sage: Set([a^(-1)*g*a for a in A4])
{(1,3,4), (1,4,2), (1,2,3), (2,4,3)}
sage: Set([a^(-1)*g*a for a in S4])
{(1,2,3), (1,3,4), (2,3,4), (2,4,3), (1,4,3), (1,2,4), (1,3,2), (1,4,2)}
</pre></div>
</div>
<p>The method <tt class="xref py py-meth docutils literal"><span class="pre">conjugacy_class_representatives()</span></tt> chooses one element from each conjugacy class.
Notice that there are two classes for 3-cycles in <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/>, but only one in <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S4.conjugacy_classes_representatives()
[(), (1,2), (1,2)(3,4), (1,2,3), (1,2,3,4)]
sage: A4.conjugacy_classes_representatives()
[(), (1,2)(3,4), (1,2,3), (1,2,4)]
</pre></div>
</div>
<p>The conjugate by <img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> of a subgroup <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> is the group <img class="math" src="_images/math/1bcb5fc962156bff36716b265a6cb3e11c0c41f8.png" alt="a^{-1}Ha"/>
(recall that multiplication is left-to right).  The group encompassing
<img class="math" src="_images/math/7dd2a5ea01fbd72ad2a58dd1f3d6ecbfde6208a1.png" alt="a"/> and <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> need not be specified; sage just considers
them inside the symmetric  group containing all the integers that
appear.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H = CyclicPermutationGroup(4)
sage: K = H.conjugate(PermutationGroupElement(&#39;(3,5)&#39;));  K
Permutation Group with generators [(1,2,5,4)]
</pre></div>
</div>
<p>The normalizer of <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> in <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> is the subgroup of elements
of <img class="math" src="_images/math/3aa8fc19c5f0b881566f218478ac9b54a071d906.png" alt="a \in S_4"/> such that <img class="math" src="_images/math/7d7b780a66fb0f7fc8b62d76296ab6295fff5eb6.png" alt="a^{-1}Ha = H"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S4.normalizer(H)
Permutation Group with generators [(2,4), (1,2,3,4), (1,3)(2,4)]
sage: H1 = H.conjugate(PermutationGroupElement(&#39;(2,4)&#39;));  H1
Permutation Group with generators [(1,4,3,2)]
sage: H1 ==H
True
</pre></div>
</div>
<p>Sage can compute all normal subgroups of a group <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/>.  Let&#8217;s
verify that <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> has 2 non-trivial normal subgroups, the
alternating group, and a group isomorphic to the Klein four group (but
not equal to sage&#8217;s standard Klein four group).</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S4 = SymmetricGroup(4)
sage: S4norms = S4.normal_subgroups(); S4norms
[Permutation Group with generators [()], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3)], Permutation Group with generators [(2,4,3), (1,3)(2,4), (1,4)(2,3)], Permutation Group with generators [(1,2), (1,2,3,4)]]
sage: K = S4norms[1];  K==KleiFourGroup()
False
sage: K.is_isomorphic(KleinFourGroup())
True
sage: A = S4norms[2]; A == AlternatingGroup(4)
True
</pre></div>
</div>
<p>We may now compute the quotient of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/> by the normal subgroups <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> and <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> in the previous example.  As expected <img class="math" src="_images/math/d9bee62e999f2c44e7f04f1a758a613095f17e25.png" alt="G/A"/>  is isomorphic to <img class="math" src="_images/math/24d27222c9e317136731eda1795569da9a9fff30.png" alt="S_2"/>. Since <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/> has 24 elements and <img class="math" src="_images/math/28e003020d0ae96250b302d7d779c791f183f707.png" alt="K"/> has 4 elements, the quotient has 6 elements.  We can check that it is isomorphic to <img class="math" src="_images/math/c1655187cb39f602362a893590a2862e71e1029d.png" alt="S_3"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G.quotient(A)
Permutation Group with generators [(1,2)]
sage: H = G.quotient(K); H
Permutation Group with generators [(1,2)(3,6)(4,5), (1,3,5)(2,4,6)]
sage: H.is_isomorphic(SymmetricGroup(3))
True
</pre></div>
</div>
<p>Sage can also compute the normalizer of a subgroup <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/>, which is the largest subgroup of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/> containing <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> in which <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> is normal.
Here we compute the normalizer of the  cyclic permutation group <img class="math" src="_images/math/48f75e0b463f2fdb7fca9566cffdc439cae6967f.png" alt="H"/> created above inside of  <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/>.  We get the dihedral group <img class="math" src="_images/math/63cae996d97e64fe714e60eea0a9aa0291d6db16.png" alt="D_4"/>.
If we had used a different 4-cycle the resulting group may have been isomorphic to <img class="math" src="_images/math/63cae996d97e64fe714e60eea0a9aa0291d6db16.png" alt="D_4"/> but not equal to it.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G.normalizer(H).cardinality()
8
sage: HK.normalizer(H)== DihedralGroup(4)
True
</pre></div>
</div>
<p>For some groups the list  of all subgroups may be large.  To better understand the subgroups of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/> we may compute one group from each conjugacy class.  The following computations show that there are 30 subgroups of <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> but only 11 up to conjugacy.  Every other subgroup is not only isomorphic to one of the 11, given by <tt class="xref py py-meth docutils literal"><span class="pre">conjugacy_classes_subgroups()</span></tt>, but is also isomorphic via conjugation by some element of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G
Symmetric group of order 4! as a permutation group
sage: G.subgroups()
[Permutation Group with generators [()], Permutation Group with generators [(1,2)(3,4)], Permutation Group with generators [(1,3)(2,4)], Permutation Group with generators [(1,4)(2,3)], Permutation Group with generators [(3,4)], Permutation Group with generators [(2,3)], Permutation Group with generators [(2,4)], Permutation Group with generators [(1,2)], Permutation Group with generators [(1,3)], Permutation Group with generators [(1,4)], Permutation Group with generators [(2,4,3)], Permutation Group with generators [(1,2,3)], Permutation Group with generators [(1,4,2)], Permutation Group with generators [(1,3,4)], Permutation Group with generators [(1,4)(2,3), (1,3)(2,4)], Permutation Group with generators [(1,2)(3,4), (3,4)], Permutation Group with generators [(1,4)(2,3), (2,3)], Permutation Group with generators [(1,3)(2,4), (2,4)], Permutation Group with generators [(1,2)(3,4), (1,3,2,4)], Permutation Group with generators [(1,3)(2,4), (1,4,3,2)], Permutation Group with generators [(1,4)(2,3), (1,2,4,3)], Permutation Group with generators [(3,4), (2,4,3)], Permutation Group with generators [(3,4), (1,3,4)], Permutation Group with generators [(1,2), (1,2,3)], Permutation Group with generators [(1,2), (1,4,2)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (1,2)], Permutation Group with generators [(1,2)(3,4), (1,3)(2,4), (1,4)], Permutation Group with generators [(1,4)(2,3), (1,2)(3,4), (1,3)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (2,4,3)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2)]]
sage: len(G.subgroups())
30
sage: G.conjugacy_classes_subgroups()
[Permutation Group with generators [()], Permutation Group with generators [(1,3)(2,4)], Permutation Group with generators [(3,4)], Permutation Group with generators [(2,4,3)], Permutation Group with generators [(1,4)(2,3), (1,3)(2,4)], Permutation Group with generators [(1,2)(3,4), (3,4)], Permutation Group with generators [(1,2)(3,4), (1,3,2,4)], Permutation Group with generators [(3,4), (2,4,3)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (1,2)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (2,4,3)], Permutation Group with generators [(1,3)(2,4), (1,4)(2,3), (2,4,3), (1,2)]]
sage: len(G.conjugacy_classes_subgroups())
11
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Find two subgroups of <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/> that are conjugate in <img class="math" src="_images/math/a1901d7b43b6c53e08101a93a443000966e6d37e.png" alt="S_4"/> but are not conjugate in <img class="math" src="_images/math/2ad64d0755585a9228b03514c78ab930ecaa36f8.png" alt="A_4"/>.</li>
</ol>
</div></blockquote>
<span class="target" id="group-homomorphisms"></span><span class="target" id="index-25"></span></div>
<div class="section" id="permutation-group-homomorphisms">
<span id="index-26"></span><h4>Permutation Group Homomorphisms<a class="headerlink" href="#permutation-group-homomorphisms" title="Permalink to this headline">¶</a></h4>
<p>To construct a homomorphism between two permutation groups we use the <tt class="xref py py-func docutils literal"><span class="pre">PermutationGroupMorphism()</span></tt> command. For an example let us use the two isomorphic groups that we constructed earlier.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = SymmetricGroup(5)
sage: r = G(&#39;(1,2,5,4,3)&#39;)
sage: s = G(&#39;(1,5),(3,4)&#39;)
sage: H = G.subgroup([r,s])
sage: H
Subgroup of SymmetricGroup(5) generated by [(1,2,5,4,3), (1,5)(3,4)]
sage: D = DihedralGroup(5)
sage: D
Dihedral group of order 10 as a permutation group
</pre></div>
</div>
<p>A homomorphism between these is constructed by listing an association between the <em>generators</em> of one group to the generators of the other. To see these we will use the <tt class="xref py py-meth docutils literal"><span class="pre">gens()</span></tt> method provided by our groups</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H.gens()
[(1,2,5,4,3), (1,5)(3,4)]
sage: D.gens()
[(1,2,3,4,5), (1,5)(2,4)]
</pre></div>
</div>
<p>We construct the homomorphism <img class="math" src="_images/math/c6a734ec582cd2b1d154fc1039659bf81b0a4180.png" alt="\phi: H \rightarrow D"/> that sends <img class="math" src="_images/math/470227515fda65a4c765fc387a7d3555869631ae.png" alt="(1,2,5,4,3) \rightarrow (1,2,3,4,5)"/> and <img class="math" src="_images/math/d279368997a671dd95d266320a5d858b3ac53128.png" alt="(1,5)(3,4) \rightarrow (1,5)(2,4)"/> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: phi = PermutationGroupMorphism(H,D,H.gens(), D.gens())
sage: phi
Homomorphism : Permutation Group with generators [(1,2,5,4,3), (1,5)(3,4)] --&gt; Dihedral group of order 10 as a permutation group
</pre></div>
</div>
<p>We can apply this homomorphism as we would any function, by calling it.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: phi( &#39;(2,3)(4,5)&#39;)
(1,3)(4,5)
sage: phi( &#39;(1,5,3,2,4)&#39;)
(1,3,5,2,4)
sage: phi(&#39;(1,5)&#39;)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
AttributeError: &#39;str&#39; object has no attribute &#39;_gap_init_&#39;
</pre></div>
</div>
<p>Note that we get an  <tt class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></tt> because the permutation
<img class="math" src="_images/math/4694c84ffe15bd1e586ebc963a719a3b825ac0cc.png" alt="(1,5)"/> is not in the domain of <tt class="xref py py-meth docutils literal"><span class="pre">phi()</span></tt>.</p>
<p id="index-27">The homomorphism also comes equipped with a few useful methods, the most useful is the <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> method, which yields the kernel of the homomorphism. Since this homomorphism is an injection, the kernel is just the trivial group.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: phi.kernel()
Permutation Group with generators [()]
</pre></div>
</div>
<p id="index-28">The <em>direct product</em> of two PermutationGroups produces another
PermutationGroup, but in a larger symmetric group. The output is a
list of length five consisting of the direct product  followed by four
homomorphisms.  The first two homomorphism are the natural ones from
each factor into the product.  The second two homomorphisms are the
natural projections from the product on to each factor.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C4 = CyclicPermutationGroup(4)
sage: C3 = CyclicPermutationGroup(3)
sage: C4xC3 = C4.direct_product(C3);  C4xC3
(Permutation Group with generators [(5,6,7), (1,2,3,4)], Permutation group morphism:
From: Cyclic group of order 4 as a permutation group
To:   Permutation Group with generators [(5,6,7), (1,2,3,4)]
Defn: Embedding( Group( [ (1,2,3,4), (5,6,7) ] ), 1 ), Permutation group morphism:
From: Cyclic group of order 3 as a permutation group
To:   Permutation Group with generators [(5,6,7), (1,2,3,4)]
Defn: Embedding( Group( [ (1,2,3,4), (5,6,7) ] ), 2 ), Permutation group morphism:
From: Permutation Group with generators [(5,6,7), (1,2,3,4)]
To:   Cyclic group of order 4 as a permutation group
Defn: Projection( Group( [ (1,2,3,4), (5,6,7) ] ), 1 ), Permutation group morphism:
From: Permutation Group with generators [(5,6,7), (1,2,3,4)]
To:   Cyclic group of order 3 as a permutation group
Defn: Projection( Group( [ (1,2,3,4), (5,6,7) ] ), 2 ))
</pre></div>
</div>
<p>If we just want the direct product group, we must select the 0th element of the direct product.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C4xC3[0]
Permutation Group with generators [(1,2,3,4), (5,6,7)]
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>There is a homomorphism from the dicyclic group of index <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> to the dihedral group of index <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> .  Construct it and find the kernel.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="matrix-groups">
<span id="id4"></span><h3>Matrix Groups<a class="headerlink" href="#matrix-groups" title="Permalink to this headline">¶</a></h3>
<p>Please contribute!</p>
</div>
<div class="section" id="abelian-groups">
<span id="id5"></span><h3>Abelian Groups<a class="headerlink" href="#abelian-groups" title="Permalink to this headline">¶</a></h3>
<p>Please contribute!</p>
<span class="target" id="linear-algebra"></span></div>
</div>
<div class="section" id="index-29">
<span id="id6"></span><h2>Linear Algebra<a class="headerlink" href="#index-29" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vectors-and-matrices">
<span id="id7"></span><h3>Vectors and Matrices<a class="headerlink" href="#vectors-and-matrices" title="Permalink to this headline">¶</a></h3>
<p id="index-30">To create a vector, use the <tt class="xref py py-func docutils literal"><span class="pre">vector()</span></tt> command with a list of
entries. Scalar multiples and the dot product are straightforward to
compute. As with lists, vectors are indexed starting from <img class="math" src="_images/math/74c081db590f3d35421c1f6b9afd4cdda36ee210.png" alt="0"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: v= vector([1,2,3,4])
sage: v[0]
1
sage: v[4]
ERROR: An unexpected error occurred while tokenizing input
</pre></div>
</div>
<p>Arithmetic on vectors is what one would expect.  Sage will produce an error message if you add two vectors of different lengths.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: 7*v
(7, 14, 21, 28)
sage: v + vector([2,1,4,5])
(3, 3, 7, 9)
sage: v*v
sage: v + vector([2,1,4])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/Users/mosullivan/Work/Sage/Tutorial/sdsu-sage-tutorial/&lt;ipython console&gt; in &lt;module&gt;()

/Applications/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.ModuleElement.__add__ (sage/structure/element.c:7627)()

/Applications/sage/local/lib/python2.6/site-packages/sage/structure/coerce.so in sage.structure.coerce.CoercionModel_cache_maps.bin_op (sage/structure/coerce.c:6995)()

TypeError: unsupported operand parent(s) for &#39;+&#39;: &#39;Ambient free module of rank 4 over the principal ideal domain Integer Ring&#39; and &#39;Ambient free module of rank 3 over the principal ideal domain Integer Ring&#39;
</pre></div>
</div>
<p id="index-31">We use the <tt class="xref py py-func docutils literal"><span class="pre">matrix()</span></tt> command to construct a matrix with a list of the <em>rows</em> of the matrix as the argument.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: matrix([[1,2],[3,4]])
[1 2]
[3 4]
</pre></div>
</div>
<p>We can also construct a matrix by specifying all of the coordinates in a single matrix while specifying the dimensions of the matrix. The following command creates a matrix with <img class="math" src="_images/math/51a8d7e791ab9e463af82a4075edb04ef8028dcf.png" alt="4"/> rows and <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> columns.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: matrix(4,2, [1,2,3,4,5,6,7,8])
[1 2]
[3 4]
[5 6]
[7 8]
</pre></div>
</div>
<p>If the matrix that we want to construct is square we can omit the number of columns from the argument.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: matrix(2,[1,2,3,4])
[1 2]
[3 4]
</pre></div>
</div>
<p>By default, Sage constructs the matrix over the smallest universe which contains the coordinates.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: parent(matrix(2,[1,2,3,4]))
Full MatrixSpace of 2 by 2 dense matrices over Integer Ring
sage: parent(matrix(2,[1,2/1,3,4]))
Full MatrixSpace of 2 by 2 dense matrices over Rational Field
sage: parent(matrix(2,[x,x^2,x-1,x^3])
Full MatrixSpace of 2 by 2 dense matrices over Symbolic Ring
</pre></div>
</div>
<p>We can specify the universe for the coordinates of a matrix or vector by giving it as an optional argument.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: matrix(QQ,2,[1.1,1.2,1.3,1.4])
[11/10   6/5]
[13/10   7/5]
</pre></div>
</div>
<p id="index-32">There are shortcuts in Sage to construct some of the more commonly used matrices. To construct the identity matrix we use the <tt class="xref py py-func docutils literal"><span class="pre">identity_matrix()</span></tt> function.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: identity_matrix(3)
[1 0 0]
[0 1 0]
[0 0 1]
</pre></div>
</div>
<p id="index-33">To construct the zero matrix we may use <tt class="xref py py-func docutils literal"><span class="pre">zero_matrix()</span></tt> or the
regular matrix function with no list  input.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: zero_matrix(2,2)
[0 0]
[0 0]
sage: matrix(2)
[0 0]
[0 0]
sage: matrix(2,3)
[0 0 0]
[0 0 0]
</pre></div>
</div>
<p>Note that if we use <tt class="xref py py-func docutils literal"><span class="pre">zero_matrix()</span></tt> we must input two integers.</p>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Use Sage to construct the vector <img class="math" src="_images/math/db2c6e7bd2bb4c1e79fac49cdb189631c043e07a.png" alt="v = \left(4, 10, 17, 28, 2 \right)"/></p>
</li>
<li><p class="first">Construct the following matrix over the rational numbers in Sage.</p>
<div class="math">
<p><img src="_images/math/fb1d012a1ee398174cc0b14aad25c6bdc6c7b149.png" alt="\left(\begin{array}{ccc}
5 &amp; 3 &amp; 2 \\
4 &amp; 7 &amp; 10 \\
2 &amp; 11 &amp; 1 \end{array}\right)"/></p>
</div></li>
<li><p class="first">Construct a 10x10 identity matrix.</p>
</li>
<li><p class="first">Construct a 20x10 zero matrix.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="matrix-arithmetic">
<span id="index-34"></span><span id="id8"></span><h3>Matrix Arithmetic<a class="headerlink" href="#matrix-arithmetic" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>You should be familiar with <a class="reference internal" href="#vectors-and-matrices"><em>Vectors and Matrices</em></a>.</div></blockquote>
<p>We may use <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">^</span></tt> for matrix addition,
subtraction, multiplication and exponents.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A=matrix(2,[1,1,0,1])
sage: B=matrix(2,[1,0,1,1])
sage: A+B
[2 1]
[1 2]
sage: A*B
[2 1]
[1 1]
sage: B*A
[1 1]
[1 2]
sage: A-B
[ 0  1]
[-1  0]
sage: A^3
[1 3]
[0 1]
</pre></div>
</div>
<p>We can compute the <em>inverse</em> of a matrix by raising it to the <img class="math" src="_images/math/80d842c5b7aabdb4c23f00d2074915d876e294f2.png" alt="-1"/> -th power.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A^-1
[ 1 -1]
[ 0  1]
</pre></div>
</div>
<p>If the matrix is not invertible Sage will complain about a <tt class="xref py py-class docutils literal"><span class="pre">ZeroDivisionError</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A = matrix([[4,2],[8,4]])
sage: A^-1
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
... (Long error message)
ZeroDivisionError: input matrix must be nonsingular
</pre></div>
</div>
<p id="index-35">When multiplying vectors and matrices; vectors can be considered both as rows or as columns, so you can multiply a 3-vector by a 3×n matrix on the right, or by a n×3 matrix on the left.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: x = vector([12,3,3])
sage: x
(12, 3, 3)
sage: A
[1 2 3]
[4 5 6]
sage: A*x
(27, 81)
sage: B = transpose(A)
sage: B
[1 4]
[2 5]
[3 6]
sage: x*B
(27, 81)
</pre></div>
</div>
<p id="index-36">We use the <tt class="xref py py-meth docutils literal"><span class="pre">det()</span></tt> method to calculate the <em>determinant</em> of a square matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A= matrix([[-1/2,0,-1],[0,-2,2],[1,0,-1/2]]); A
[-1/2    0   -1]
[   0   -2    2]
[   1    0 -1/2]
sage: A.det()
-5/2
</pre></div>
</div>
<p id="index-37">To check if a matrix is invertible we use the <tt class="xref py py-meth docutils literal"><span class="pre">is_invertible()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A=matrix(2,[1,1,0,1])
sage: A.is_invertible()
True
sage: A.det()
1
</pre></div>
</div>
<p>The invertablility of a matrix depends on the ring or field it is defined over. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: B=matrix(2,[1,2,3,4])
sage: B.is_invertible()
False
</pre></div>
</div>
<p>In this example, Sage assumes that the matrix <tt class="docutils literal"><span class="pre">B</span></tt> is defined over the integers and not the rationals, where it does not have an inverse. But if we define <tt class="docutils literal"><span class="pre">B</span></tt> as a matrix over the rationals, we obtain different results.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: B = matrix(QQ, 2,[1,2,3,4])
sage: B
[1 2]
[3 4]
sage: B.is_invertible()
True
</pre></div>
</div>
<p>If we ask Sage to compute the inverse of a matrix over the integers it will automatically coerce <tt class="docutils literal"><span class="pre">B</span></tt> into a matrix over the rationals if necessary.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: B = matrix(2,[1,2,3,4])
sage: parent(B)
Full MatrixSpace of 2 by 2 dense matrices over Integer Ring
sage: B^-1
[  -2    1]
[ 3/2 -1/2]
sage: parent(B^-1)
Full MatrixSpace of 2 by 2 dense matrices over Rational Field
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Consider the matrices:</p>
<div class="math">
<p><img src="_images/math/9054c61addb46ae1b9fb1b114314984ee5e3d632.png" alt="A = \left(\begin{array}{cc}
  1 &amp; 3 \\
  7 &amp; 8 \end{array} \right) \quad \textrm{and} \quad
  B = \left(\begin{array}{cc}
  4 &amp; 8 \\
  9 &amp; 15 \end{array} \right)

Compute the following:

 a) :math:`A + B`
 b) :math:`AB`
 c) :math:`B^{-1}`
 d) :math:`B^{-1} A B`"/></p>
</div></li>
<li><p class="first">Which of the following matrices is invertable over <img class="math" src="_images/math/5fdff137bc42a8949aa1b49bbb9418c4bd6f4230.png" alt="\mathbb{Z}"/>? What about <img class="math" src="_images/math/7460925db718da589258ca5ba22dd1eed447a065.png" alt="\mathbb{Q}"/>?</p>
<div class="math">
<p><img src="_images/math/6f0e0fcedc5224811576ede2f807eac668082967.png" alt="A = \left(\begin{array}{cc}
2 &amp; 8 \\
4 &amp; 16 \end{array} \right) \qquad
B = \left(\begin{array}{cc}
2 &amp; 7 \\
13 &amp; 24 \end{array} \right) \qquad
C = \left(\begin{array}{cc}
1 &amp; 4 \\
2 &amp; 7 \end{array} \right) \qquad
D = \left(\begin{array}{cc}
4 &amp; 6 \\
8 &amp; -2 \end{array} \right)"/></p>
</div></li>
</ol>
</div></blockquote>
<span class="target" id="matrix-manipulation"></span></div>
<div class="section" id="index-38">
<span id="id9"></span><h3>Matrix Manipulation<a class="headerlink" href="#index-38" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>You should be familiar with <a class="reference internal" href="#vectors-and-matrices"><em>Vectors and Matrices</em></a> and <a class="reference internal" href="#matrix-arithmetic"><em>Matrix Arithmetic</em></a>.</div></blockquote>
<p>In this section we will cover some of the commands that we can use to <em>manipulate</em> matrices. Let&#8217;s begin by defining a matrix over the rational numbers.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = matrix(QQ, [[1,2,3],[4,5,6],[7,8,9]]); M
[1 2 3]
[4 5 6]
[7 8 9]
</pre></div>
</div>
<p id="index-39">To get a list of row and column vectors, we use the <tt class="xref py py-meth docutils literal"><span class="pre">rows()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">columns()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.rows()
[(1, 2, 3), (4, 5, 6), (7, 8, 9)]
sage: M.columns()
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
</pre></div>
</div>
<p id="index-40">The following examples show how to get a particular row or column
vector. Remember tl that Sage follows Python&#8217;s convention that all of the indicies begin with zero.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.row(0)
(1, 2, 3)
sage: M.row(2)
(7, 8, 9)
sage: M.column(1)
(2, 5, 8)
sage: M.column(2)
(3, 6, 9)
</pre></div>
</div>
<p id="index-41">You can even get a list of the diagonal entries, by calling the <tt class="xref py py-meth docutils literal"><span class="pre">diagonal()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.diagonal()
[1, 5, 9]
</pre></div>
</div>
<p id="index-42">Sage also allows us to contruct new matrices from the row and/or column vectors.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.matrix_from_columns([0,2])
[1 3]
[4 6]
[7 9]
sage: M.matrix_from_rows([0,2])
[1 2 3]
[7 8 9]
sage: M.matrix_from_rows_and_columns([0,2],[0,2])
[1 3]
[7 9]
</pre></div>
</div>
<p>It should be noted that the <tt class="xref py py-meth docutils literal"><span class="pre">matrix_from_rows_and_columns()</span></tt> returns the <em>intersection</em> of the rows and columns specified. In the above example we are selecting the matrix that consists of the four &#8216;corners&#8217; of our <img class="math" src="_images/math/59ca78535a2bfd005ddf503222102c74a0199b90.png" alt="3\times3"/> matrix.</p>
<p id="index-43">Next we will discuss some of the elementary row operations. To multiply a row or column by a number we use the <tt class="xref py py-meth docutils literal"><span class="pre">rescale_row()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">rescale_column()</span></tt> methods. Note that these commands change the matrix itself.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.rescale_row(1,-1/4); M
[   1    2    3]
[  -1 -5/4 -3/2]
[   7    8    9]
sage: M.rescale_col(2,-1/3); M
[   1    2   -1]
[  -1 -5/4  1/2]
[   7    8   -3]
sage: M.rescale_row(1,-4); M
[ 1  2 -1]
[ 4  5 -2]
[ 7  8 -3]
</pre></div>
</div>
<p id="index-44">We can add a multiple of a row or column to another row or column by
using the <tt class="xref py py-meth docutils literal"><span class="pre">add_multiple_of_row()</span></tt> method. The first command takes
<img class="math" src="_images/math/f3d47cec8619f9fe0e79081de8331ee27849d56a.png" alt="-4"/> times the row <img class="math" src="_images/math/74c081db590f3d35421c1f6b9afd4cdda36ee210.png" alt="0"/>  and adds it to row <img class="math" src="_images/math/123e375e88da91240024aaf085abee194c4a2d06.png" alt="1"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.add_multiple_of_row(1,0,-4); M
[ 1  2 -1]
[ 0 -3  2]
[ 7  8 -3]
sage: M.add_multiple_of_row(2,0,-7); M
[ 1  2 -1]
[ 0 -3  2]
[ 0 -6  4]
</pre></div>
</div>
<p id="index-45">The same can be done with the column vectors, which are also zero indexed.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.add_multiple_of_column(1,0,-2);M
[ 1  0 -1]
[ 0 -3  2]
[ 0 -6  4]
sage: M.add_multiple_of_column(2,0,1);M
[ 1  0  0]
[ 0 -3  2]
[ 0 -6  4]
</pre></div>
</div>
<p id="index-46">If we don&#8217;t like the ordering of our rows or colums we can swap them in place.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.swap_rows(1,0); M
[ 0 -3  2]
[ 1  0  0]
[ 0 -6  4]
sage: M.swap_columns(0,2); M
[ 2 -3  0]
[ 0  0  1]
[ 4 -6  0]
</pre></div>
</div>
<p id="index-47">If we want to change a row or column of <cite>M</cite> then we use the <tt class="xref py py-meth docutils literal"><span class="pre">set_column()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">set_row()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.set_column(0,[1,2,3]);M
[ 1 -3  0]
[ 2  0  1]
[ 3 -6  0]
sage: M.set_row(0,[1,2,5]);M
[ 1  2  5]
[ 2  0  1]
[ 3 -6  0]
</pre></div>
</div>
<p id="index-48">And finally if we want to change a whole &#8220;block&#8221; of a matrix, we use the <tt class="xref py py-meth docutils literal"><span class="pre">set_block()</span></tt> method with the coordinates of where we want the upper left corner of the block to begin.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: B = matrix(QQ,[ [1,0 ],[0,1]]); B
[1 0]
[0 1]
sage: M.set_block(1,1,B); M
[1 2 5]
[2 1 0]
[3 0 1]
</pre></div>
</div>
<p id="index-49">Of course, if all we want is the <em>echelon form</em> of the matrix we can use either the <tt class="xref py py-meth docutils literal"><span class="pre">echelon_form()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">echelonize()</span></tt> methods. The difference between the two is the former returns a copy of the matrix in echelon form without changing the original matrix and the latter alters the matrix itself.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.echelon_form()
[1 0 0]
[0 1 0]
[0 0 1]

sage: M.echelonize(); M
[ 1  0  0]
[ 0  1  0]
[ 0  0  1]
</pre></div>
</div>
<p>Next we  use the <em>augmented</em> matrix and the echelon form to solve a <img class="math" src="_images/math/dc5725e618c57476ee98d56f841d70551350c3ac.png" alt="3\times 4"/> system of the form <img class="math" src="_images/math/34759bf6090678ad7a19066c62e9ed98eef4456d.png" alt="Mx = b"/>. First we define the matrix <cite>M</cite> and the vector <cite>b</cite></p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = matrix(QQ,   [[2,4,6,2,4],[1,2,3,1,1],[2,4,8,0,0],[3,6,7,5,9]]); M
[2 4 6 2 4]
[1 2 3 1 1]
[2 4 8 0 0]
[3 6 7 5 9]
sage: b = vector(QQ, [56, 23, 34, 101])
</pre></div>
</div>
<p id="index-50">Then we construct the augmented matrix <img class="math" src="_images/math/21d3f6dd38ac3ffa1aecf63d1716c2a60da2848a.png" alt="\left( M\ \vert b  \right)"/>, store it in the variable <cite>M_aug</cite> and compute it&#8217;s echelon form.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M_aug = M.augment(b); M_aug
[  2   4   6   2   4  56]
[  1   2   3   1   1  23]
[  2   4   8   0   0  34]
[  3   6   7   5   9 101]
sage: M_aug.echelon_form()
[ 1  2  0  4  0 21]
[ 0  0  1 -1  0 -1]
[ 0  0  0  0  1  5]
[ 0  0  0  0  0  0]
</pre></div>
</div>
<p>This tells us that we have a one dimensional solution space that  consists of vectors of the form <img class="math" src="_images/math/4d10e787d5cb0b474492939bb4a2cf6fcfbbff89.png" alt="{v = c \left(-2,1,0,0,0 \right) + \left(21,0,1,0,5\right)}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M*vector([21,0,-1,0,5])
(56, 23, 34, 101)
sage  M*vector([-2,1,0,0,0])
(0, 0, 0, 0)
</pre></div>
</div>
<p id="index-51">If all we need is a <em>single</em> solution to this system, we can use the <tt class="xref py py-meth docutils literal"><span class="pre">solve_right()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.solve_right(b)
(21, 0, -1, 0, 5)
</pre></div>
</div>
<p id="vectors-and-matrices-arithmetic"><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Consider the matrix.</p>
<div class="math">
<p><img src="_images/math/1a6a7d009d55a3c9f74fe8cc7f34dfb28da464a3.png" alt="A = \left(\begin{array}{ccc}
4 &amp; 17 &amp; 23  \\
1/32 &amp; 2 &amp; 17 \\
16 &amp; -23 &amp; 27 \end{array} \right)"/></p>
</div><p>Use only the elementary row operations discussed to put <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> into <em>echelon</em> form.</p>
</li>
<li><p class="first">Using the commands discussed in this section, transform the matrix on the left into the matrix on the right.</p>
</li>
</ol>
<ol class="loweralpha">
<li><div class="first math">
<p><img src="_images/math/d8218785141dee208d881621068db68d2630b1fd.png" alt="\left(\begin{array}{rrrrr}
-7 &amp; -1 &amp; 1 &amp; 4 &amp; 0 \\
-8 &amp; -2 &amp; 4 &amp; 2 &amp; 6 \\
1 &amp; 1 &amp; -3 &amp; 3 &amp; 0 \\
0 &amp; 8 &amp; 13 &amp; -2 &amp; 0 \\
1 &amp; 4 &amp; 0 &amp; -1 &amp; 4
\end{array}\right) \quad \quad
\left(\begin{array}{rrrrr}
-7 &amp; -8 &amp; 1 &amp; 0 &amp; 1 \\
-1 &amp; -2 &amp; 1 &amp; 8 &amp; 4 \\
1 &amp; 4 &amp; -3 &amp; 13 &amp; 0 \\
4 &amp; 2 &amp; 3 &amp; -2 &amp; -1 \\
0 &amp; 6 &amp; 0 &amp; 0 &amp; 4
\end{array}\right)"/></p>
</div></li>
<li><div class="first math">
<p><img src="_images/math/b8fb67170933c93e390e31f9e1177e37031f7d38.png" alt="\left(\begin{array}{rrrr}
-1 &amp; -2 &amp; 1 &amp; -13 \\
-3 &amp; -1 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; -1 &amp; 1 \\
-2 &amp; -1 &amp; -9 &amp; 1
\end{array}\right) \quad \quad
\left(\begin{array}{rrrr}
1 &amp; 0 &amp; 0 &amp; 100 \\
0 &amp; 1 &amp; 0 &amp; 12 \\
0 &amp; 0 &amp; 1 &amp; 111 \\
0 &amp; 0 &amp; 0 &amp; 202
\end{array}\right)"/></p>
</div></li>
<li><div class="first math">
<p><img src="_images/math/bb15482dc0ce633e5488c66d7f41c636a5dea6e2.png" alt="\left(\begin{array}{rrr}
0 &amp; -1 &amp; 1 \\
-2 &amp; 1 &amp; -1 \\
1 &amp; 0 &amp; 1
\end{array}\right) \quad \quad
\left(\begin{array}{rrrr}
0 &amp; -1 &amp; 1 &amp; -4 \\
-2 &amp; 1 &amp; -1 &amp; -1 \\
1 &amp; 0 &amp; 1 &amp; 1
\end{array}\right)"/></p>
</div></li>
</ol>
</div></blockquote>
<span class="target" id="vector-and-matrix-spaces"></span></div>
<div class="section" id="index-52">
<span id="id10"></span><h3>Vector and Matrix Spaces<a class="headerlink" href="#index-52" title="Permalink to this headline">¶</a></h3>
<p id="index-53">It is sometimes useful to create the space of all matrices of
particular dimension, for which we use the <tt class="xref py py-func docutils literal"><span class="pre">MatrixSpace()</span></tt>
function. We must specify the field (or indeed any ring) where the
entries live.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: MatrixSpace(QQ,2,3)
Full MatrixSpace of 2 by 3 dense matrices over Rational Field
</pre></div>
</div>
<p>If we input a ring <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> and an integer <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> we get the
matrix ring of <img class="math" src="_images/math/fc2f930a1ad69d51fcd5c5e981924e0f0e0bbbcb.png" alt="n\times n"/>
matrices over <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/>. Coercion can be used to construct the zero matrix, the
indentity matrix, or a matrix with specified entries as shown.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Mat = MatrixSpace(ZZ,2); Mat
Full MatrixSpace of 2 by 2 dense matrices over Integer Ring
sage: Mat(1)
[1 0]
[0 1]
sage: Mat(0)
[0 0]
[0 0]
sage: Mat([1,2,3,4])
[1 2]
[3 4]
</pre></div>
</div>
<p id="index-54">We may compute various spaces associated to a matrix.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Mat = MatrixSpace(QQ, 3,4)
sage: A = Mat([[1,2,3,4], [1,3,4,4],[2,5,7,8]])
sage: A
[1 2 3 4]
[1 3 4 4]
[2 5 7 8]
sage: A.rank()
2
sage: A.right_kernel()
Vector space of degree 4 and dimension 2 over Rational Field
Basis matrix:
[   1    0    0 -1/4]
[   0    1   -1  1/4]
sage: A.left_kernel()
Vector space of degree 3 and dimension 1 over Rational Field
Basis matrix:
[ 1  1 -1]
sage: A.row_space()
Vector space of degree 4 and dimension 2 over Rational Field
Basis matrix:
[1 0 1 4]
[0 1 1 0]
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<ol class="arabic">
<li><p class="first">For the following 5x3 matrix:</p>
<div class="math">
<p><img src="_images/math/3167b22b812507168c7a0b5df2c40732a122c85e.png" alt="\left(\begin{array}{rrr}
1 &amp; -1 &amp; -1 \\
0 &amp; 1 &amp; -3 \\
1 &amp; 1 &amp; 1 \\
0 &amp; -6 &amp; -20 \\
0 &amp; 0 &amp; 0
\end{array}\right)"/></p>
</div><p>Use Sage to compute the bases for the following spaces:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>The right and left kernel.</li>
<li>The row space.</li>
<li>The column space.</li>
</ol>
</div></blockquote>
</li>
</ol>
<span class="target" id="vectors-and-matrices-jordan-form"></span></div>
<div class="section" id="mini-topic-the-jordan-canonical-form">
<span id="index-55"></span><h3>Mini-Topic: The Jordan Canonical Form<a class="headerlink" href="#mini-topic-the-jordan-canonical-form" title="Permalink to this headline">¶</a></h3>
<p>For every linear transformation <img class="math" src="_images/math/0778340c01631579df6fea76c813ff480590bcdf.png" alt="\mathrm{T}:\mathbb{R}^n \longrightarrow \mathbb{R}^{n}"/> there is a basis of <img class="math" src="_images/math/8305a1ff737d7c82636c29557804352a23327c11.png" alt="\mathbb{R}^n"/> such that the matrix <img class="math" src="_images/math/dc572679cccf6c6cd31990a716f3e2e6dcdd48b6.png" alt="\left[m\right]_{\mathcal{B}}"/> is in an <em>almost</em> diagonal form. This unique matrix is called the <em>Jordan Canonical Form</em> of <img class="math" src="_images/math/9c6b80fdfc4cd03af6a93fcd4908afa89c0de4a2.png" alt="\mathrm{T}"/>. For more information on this please refer to this <a class="reference external" href="http://en.wikipedia.org/wiki/Jordan_normal_form">article</a> on Wikipedia. To demonstrate some common tools that we use in Sage we will compute this basis for the linear transformation</p>
<div class="math">
<p><img src="_images/math/156301abde40503534beb64ef781d4aa2a216e90.png" alt="\mathrm{T}\left(x,y,z,t \right) = \left(2x+y, 2y+1, 3z, y-z+3t \right)."/></p>
</div><p>We will begin by defining <img class="math" src="_images/math/9c6b80fdfc4cd03af6a93fcd4908afa89c0de4a2.png" alt="\mathrm{T}"/> in Sage.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: T(x,y,z,t) = (2*x+y, 2*y+1, 3*z, y - z + 3*t)
</pre></div>
</div>
<p id="index-56">Now, let&#8217;s use the standard ordered basis of <img class="math" src="_images/math/c5c2e59778e48347320e2fd1db4fdf42eebaa35d.png" alt="\mathbb{R}^3"/> to find the matrix form of <img class="math" src="_images/math/9c6b80fdfc4cd03af6a93fcd4908afa89c0de4a2.png" alt="\mathrm{T}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: T(1,0,0,0), T(0,1,0,0), T(0,0,1,0), T(0,0,0,1)
((2, 1, 0, 0), (1, 3, 0, 1), (0, 1, 3, -1), (0, 1, 0, 3))
</pre></div>
</div>
<p>Note that since Sage uses rows to construct a matrix we must use the  <tt class="xref py py-func docutils literal"><span class="pre">transpose()</span></tt> function to get the matrix we expect.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M = transpose(matrix([[2,1,0,0],[0,2,1,0],  [0,0,3,0],[0,1,-1,3]]));  M
[ 2  1  0  0]
[ 0  2  1  0]
[ 0  0  3  0]
[ 0  1 -1  3]
</pre></div>
</div>
<p id="index-57">Once we have the matrix we will compute it&#8217;s <em>characteristic polynomial</em> and then factor it.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: f = M.characteristic_polynomial(); f
x^4 - 10*x^3 + 37*x^2 - 60*x + 36
sage: f.factor()
(x - 3)^2 * (x - 2)^2
</pre></div>
</div>
<p id="index-58">Above  we have two eigenvalues <img class="math" src="_images/math/7f90ebdcae85de23d03e5233ba90b4615065d782.png" alt="\lambda_1 = 3"/> and <img class="math" src="_images/math/fcc74268ed1409bcb1a38211121e8271b8f45db7.png" alt="\lambda_2 = 2"/> and both are of algebraic multiplicity <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/>. Now we need to look at the associated  <em>eigenvectors</em>. To do so we will use the <tt class="xref py py-meth docutils literal"><span class="pre">eigenvectors_right()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: ev_M = M.eigenvectors_right(); ev_M
[(3, [
(1, 1, 1, 0),
(0, 0, 0, 1)
], 2), (2, [
(1, 0, 0, 0)
], 2)]
sage: ev_M[1][1][0]
(1, 0, 0, 0)
</pre></div>
</div>
<p id="index-59">What is returned is a <a class="reference external" href="http://docs.python.org/library/functions.html#list" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">list()</span></tt></a> of ordered tripples. Each triple is
consists  of an eigenvalue followed by a list with a basis for the
associated  eigenspace followed by the dimension of the associated eigenspace. Note that the eigenvalue <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> has algebraic multiplicity of <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> but geometric multiplicity only <img class="math" src="_images/math/123e375e88da91240024aaf085abee194c4a2d06.png" alt="1"/>. This means that we will have to compute a <em>generalized eigenvector</em> for this eigenvalue. We will do this by solving the system <img class="math" src="_images/math/09b5300e95835fda60eae00b9a09a93e24e25e0c.png" alt="\left(M - 2\mathrm{I}\right) v = x"/>, where <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> is the eigenvector <img class="math" src="_images/math/7c07dfaffc4265b7f5dd5e8d3cfdeafc35501d49.png" alt="\left(1,0,0,0\right)"/>. I will use the <tt class="xref py py-meth docutils literal"><span class="pre">echelon_form()</span></tt> of the augmented matrix to solve the system.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: (M - 2*identity_matrix(4)).augment(ev_M[1][1][0])
[ 0  1  0  0  1]
[ 0  0  1  0  0]
[ 0  0  1  0  0]
[ 0  1 -1  1  0]
sage: _.echelon_form()
[ 0  1  0  0  1]
[ 0  0  1  0  0]
[ 0  0  0  1 -1]
[ 0  0  0  0  0]
sage: gv = vector([1,1,0,-1]); gv
(1, 1, 0, -1)
</pre></div>
</div>
<p id="index-60">With the generalized eigenvector <cite>gv</cite>, we now have the right number of linearly independent vectors to form a basis for our <em>Jordan Form</em> matrix. We will next form the <em>change of basis matrix</em> that consists of these vectors as columns.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S = transpose( matrix( [[1,1,1,0],[0,0,0,1],[1,0,0,0],gv])); S
[ 1  0  1  1]
[ 1  0  0  1]
[ 1  0  0  0]
[ 0  1  0 -1]
</pre></div>
</div>
<p id="index-61">Now we will compute the matrix representation of <img class="math" src="_images/math/9c6b80fdfc4cd03af6a93fcd4908afa89c0de4a2.png" alt="\mathrm{T}"/> with respect to this basis.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S.inverse()*M*S
[3 0 0 0]
[0 3 0 0]
[0 0 2 1]
[0 0 0 2]
</pre></div>
</div>
<p id="index-62">And there it is, the <em>Jordan Canonical Form</em> of the linear transformation <img class="math" src="_images/math/9c6b80fdfc4cd03af6a93fcd4908afa89c0de4a2.png" alt="\mathrm{T}"/>. Of course we could have just used Sage&#8217;s built in <tt class="xref py py-meth docutils literal"><span class="pre">jordan_form()</span></tt> method to compute this directly.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.jordan_form()
[3|0|0 0]
[-+-+---]
[0|3|0 0]
[-+-+---]
[0|0|2 1]
[0|0|0 2]
</pre></div>
</div>
<p>But that wouldn&#8217;t be any fun!</p>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Compute a jordan basis for the following matrix using the steps outlined in this section.</p>
<div class="math">
<p><img src="_images/math/775bce4b9b98e1d3e695352ef76b49033ce4d374.png" alt="\left(\begin{array}{rrrr}
1 &amp; 2 &amp; 0 &amp; 2 \\
0 &amp; 2 &amp; 0 &amp; 0 \\
-1 &amp; 2 &amp; -\frac{1}{2} &amp; -2 \\
0 &amp; 2 &amp; 0 &amp; 2
\end{array}\right)"/></p>
</div></li>
</ol>
</div></blockquote>
<span class="target" id="rings"></span></div>
</div>
<div class="section" id="index-63">
<span id="id11"></span><h2>Rings<a class="headerlink" href="#index-63" title="Permalink to this headline">¶</a></h2>
<div class="section" id="polynomial-rings">
<span id="index-64"></span><span id="id12"></span><h3>Polynomial Rings<a class="headerlink" href="#polynomial-rings" title="Permalink to this headline">¶</a></h3>
<p id="index-65">Constructing polynomial rings in Sage is fairly straightforward. We
just specify the name of the &#8220;indeterminate&#8221; variable as well as the
coefficient ring.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(ZZ)
sage: R
Univariate Polynomial Ring in x over Integer Ring
</pre></div>
</div>
<p id="index-66">Once the polynomial ring has been defined we can construct a polynomial without any special coercions.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p = 2*x^2 + (1/2)*x + (3/5)
sage: parent(p)
Univariate Polynomial Ring in x over Rational Field
</pre></div>
</div>
<p id="index-67">Though <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> is the most common choice for a variable, we could have chosen
any letter for the indeterminate.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;Y&gt;=PolynomialRing(QQ)
sage: R
Univariate Polynomial Ring in Y over Rational Field
</pre></div>
</div>
<p id="index-68">Polynomials with rational coefficients in Y are now valid objects in Sage.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: q = Y^4 + (1/2)*Y^3 + (1/3)*Y + (1/4)
sage: q
Y^4 + 1/2*Y^3 + 1/3*Y + 1/4
sage: parent(q)
Univariate Polynomial Ring in Y over Rational Field
</pre></div>
</div>
<p id="index-69">We can define polynomial rings over any ring or field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Z7=Integers(7)
sage: R.&lt;x&gt;=PolynomialRing(Z7); R
Univariate Polynomial Ring in x over Ring of integers modulo 7
</pre></div>
</div>
<p id="index-70">When entering a polynomial into Sage the coefficients are automatically coerced into the ring or field specified.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p = 18*x^2 + 7*x + 16; p
4*x^2 + 2
sage: parent(p)
Univariate Polynomial Ring in x over Ring of integers modulo 7
</pre></div>
</div>
<p>Of course this coercion has to be well defined.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: q  = x^4 + (1/2)*x^3 + (1/3)*x^2 + (1/4)*x + (1/5)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)  ...
TypeError: unsupported operand parent(s) for &#39;*&#39;: &#39;Rational Field&#39; and &#39;Univariate Polynomial Ring in x over Ring of integers modulo 7&#39;
</pre></div>
</div>
<p id="index-71">When prudent, Sage will extend the universe of definition to fit the polynomial entered. For example, if we ask for a rational coefficient in a polynomial ring over <img class="math" src="_images/math/5fdff137bc42a8949aa1b49bbb9418c4bd6f4230.png" alt="\mathbb{Z}"/>, Sage will naturally coerce this polynomial into a ring over <img class="math" src="_images/math/7460925db718da589258ca5ba22dd1eed447a065.png" alt="\mathbb{Q}"/></p>
<div class="highlight-python"><div class="highlight"><pre>sage: S.&lt;y&gt;=PolynomialRing(ZZ)
sage: 1/2*y
1/2*y
sage: parent(1/2*y)
Univariate Polynomial Ring in y over Rational Field
</pre></div>
</div>
<p>It should be noted that the ring <tt class="docutils literal"><span class="pre">S</span></tt> hasn&#8217;t been changed at all. Nor is <tt class="docutils literal"><span class="pre">(1/2)*y`</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">universe</span> <span class="pre">``S</span></tt>. This can be easily verified.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S
Univariate Polynomial Ring in y over Integer Ring
sage: (1/2)*y in S
False
</pre></div>
</div>
<p id="index-72">Once constructed, the basic arithmetic with polynomials is straightforward.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(QQ)
sage: f=x+1
sage: g=x^2+x-1
sage: h=1/2*x+3/4
sage: f+g
x^2 + 2*x
sage: g-h
x^2 + 1/2*x - 7/4
sage: f*g
x^3 + 2*x^2 - 1
sage: h^3
1/8*x^3 + 9/16*x^2 + 27/32*x + 27/64
</pre></div>
</div>
<p>We can also divide elements of the polynomial ring, but this changes  the parent.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: f/g
(x + 1)/(x^2 + x - 1)
sage: parent(f/g)
Fraction Field of Univariate Polynomial Ring in x over Rational Field
</pre></div>
</div>
<p id="index-73">A fundamental attribute of a polynomial is its degree. We use the <tt class="xref py py-meth docutils literal"><span class="pre">degree()</span></tt> method to calculate this.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(QQ)
sage: (x^3+3).degree()
3
sage: R(0).degree()
-1
</pre></div>
</div>
<p>Notice that by convention Sage sets the degree of 0 to be -1.</p>
<p>The polynomial ring over a field has a division algorithm. As with the integers, we may use the <tt class="docutils literal"><span class="pre">//</span></tt> operator to determine the <em>quotient</em> and the <tt class="docutils literal"><span class="pre">%</span></tt> operator to determine the <em>remainder</em> of a division.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(Integers(7))
sage: f=x^6+x^2+1
sage: g=x^3+x+1
sage: f // g
x^3 + 6*x + 6
sage: f % g
2*x^2 + 2*x + 2
</pre></div>
</div>
<p id="index-74">Additionally, if the coefficients of the polynomial are in <img class="math" src="_images/math/5fdff137bc42a8949aa1b49bbb9418c4bd6f4230.png" alt="\mathbb{Z}"/> or <img class="math" src="_images/math/7460925db718da589258ca5ba22dd1eed447a065.png" alt="\mathbb{Q}"/>, we may use the <a class="reference external" href="http://docs.python.org/library/functions.html#divmod" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">divmod()</span></tt></a> command to compute both at the same time.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: S.&lt;y&gt;=PolynomialRing(QQ)
sage: a=(y+1)*(y^2+1)
sage: b=(y+1)*(y+5)
sage: a // b
y - 5
sage: a % b
26*y + 26
sage: divmod(a,b)
(y - 5, 26*y + 26)
</pre></div>
</div>
<p id="index-75">For a field  <img class="math" src="_images/math/183421431fcc0a42e22f825a33dcc3c51607fa6e.png" alt="F"/>, the polynomial ring <img class="math" src="_images/math/7d71bb7a0516ff9c5864fd67d40e753d66e3767c.png" alt="F[x]"/> has a division algorithm, so we have a unique greatest common divisor (gcd) of polynomials. This can be computed using the <tt class="xref py py-func docutils literal"><span class="pre">gcd()</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt; = PolynomialRing(QQ)
sage: p = x^4 + 2*x^3 + 2*x^2 + 2*x + 1
sage: q = x^4 - 1
sage: gcd(p,q)
x^3 + x^2 + x + 1
</pre></div>
</div>
<p id="index-76">The greatest common divisor of two integers can be represented as a linear combination of the two integers, and the extended Euclidean algorithm is used to determine one such linear combination. Similarly, the greatest common divisor of  polynomials <img class="math" src="_images/math/2587ca10f695c9bacd43fbec192902f8682d3e91.png" alt="a(x)"/> and <img class="math" src="_images/math/9296ecef7ddf1c7fae1489705a571da133334963.png" alt="b(x)"/> may be written in the form <img class="math" src="_images/math/0faafe2a505413e1fe82a173494c1d00a8e1a12d.png" alt="a(x)f(x) + b(x)g(x)"/> for some polynomials <img class="math" src="_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/> and <img class="math" src="_images/math/3af1f844d2ef477235eb582f56085d4b53bf7568.png" alt="g(x)"/>.  We may use the <tt class="xref py py-func docutils literal"><span class="pre">xgcd()</span></tt> function to compute the  multipliers  <img class="math" src="_images/math/14546c27a7b929642f7840acca5f851c503ea109.png" alt="f(x)"/> and <img class="math" src="_images/math/3af1f844d2ef477235eb582f56085d4b53bf7568.png" alt="g(x)"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(ZZ)
sage: a=x^4-1
sage: b=(x+1)*x
sage: xgcd(a,b)
(x + 1, -1, x^2 - x + 1)
sage: d,u,v=xgcd(a,b)
sage: a*u+b*v
x + 1
</pre></div>
</div>
<p id="index-77">To check whether a polynomial is irreducible, we use it&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">is_irreducible()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(Integers(5))
sage: (x^3+x+1).is_irreducible()
True
sage: (x^3+1).is_irreducible()
False
</pre></div>
</div>
<p>This method is only suitable for polynomial rings that are defined over a field, as polynomials defined more generally may not  posses a unique factorization.</p>
<p id="index-78">To compute the <em>factorization</em> of a polynomial, where defined, we use the <tt class="xref py py-func docutils literal"><span class="pre">factor()</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(Integers(5))
sage: factor(x^3+x+1)
x^3 + x + 1
sage: factor(x^3+1)
(x + 1) * (x^2 + 4*x + 1)
</pre></div>
</div>
<p>In the example above, we see a confirmation that <img class="math" src="_images/math/b67f7e36098125e4da6ee330346d78a5496fd03e.png" alt="x^3+x+1"/> is
irreducible in <img class="math" src="_images/math/775b601d7f8a0857dc63b845c83d4fc9e7133f6e.png" alt="\mathbb{Z}_{5}[x]"/> whereas <img class="math" src="_images/math/19f03194d3d6d6b70d65dbbb66f8c2c323e5543a.png" alt="x^3+1"/> may be
factored, hence is reducible.</p>
<p>We can also consider polynomials in <img class="math" src="_images/math/74fc50cb9e221c8ee7b9ae8ce27089521b2de65c.png" alt="R[x]"/> as functions from <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> to <img class="math" src="_images/math/9d86170e7de539c0ff999de09621ee0c7b6c8ed0.png" alt="R"/> by <em>evaluation</em>, that is by substituting the indeterminate variable with a member of the coefficient ring. Evaluation of polynomials in Sage works as expected, by <em>calling</em> the polynomial like a function.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt;=PolynomialRing(Integers(3))
sage: f=2*x+1
sage: f(0)
1
sage: f(1)
0
sage: f(2)
2
</pre></div>
</div>
<p id="index-79">Calculating the <em>roots</em>, or <em>zeros</em>, of a polynomial can be done by using the <tt class="xref py py-meth docutils literal"><span class="pre">roots()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: ((x-1)^2*(x-2)*x^3).roots()
[(2, 1), (1, 2), (0, 3)]
</pre></div>
</div>
<p>Sage returns a list of pairs <img class="math" src="_images/math/2f2d1e4b35639adbdc7a1baba60a9f4fce83152b.png" alt="(r,m)"/> where <tt class="docutils literal"><span class="pre">r</span></tt> is the root and <tt class="docutils literal"><span class="pre">m</span></tt> is it&#8217;s multiplicity. Of course, a polynomial need not have any roots and in this case the <em>empty list</em> is returned.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: (x^2+1).roots()
[]
</pre></div>
</div>
<div class="section" id="multivariate-polynomial-rings">
<span id="index-80"></span><h4>Multivariate Polynomial Rings<a class="headerlink" href="#multivariate-polynomial-rings" title="Permalink to this headline">¶</a></h4>
<p id="index-81">Defining a polynomial ring with more that one variable can be done easily by supplying an extra argument to <tt class="xref py py-func docutils literal"><span class="pre">PolynomialRing()</span></tt> which specifies the number of variables desired.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x,y,z&gt; = PolynomialRing(QQ, 3)
sage: p = -1/2*x - y*z - y + 8*z^2; p
-y*z + 8*z^2 - 1/2*x - y
</pre></div>
</div>
<p>Unlike with univariate polynomials, there is not a single way that we can order the terms of a polynomial. So to specify things like the <em>degree</em> and the <em>leading term</em> of a polynomial we must first fix a rule for deciding when one term is larger than another.  If no argument is specified, Sage defaults to the <em>graded reverse lexicographic</em> ordering, sometimes referred to as <em>grevlex</em>, to make these decisions. To read more about <em>Monomial Orderings</em>, see this <a class="reference external" href="http:http://en.wikipedia.org/wiki/Monomial_order">page</a> on Wikipedia.</p>
<p id="index-82">To access a list of the monomials with nonzero coefficients in
<img class="math" src="_images/math/3eca8557203e86160952e1c0f735f7417f3285b1.png" alt="p"/>, you use the <tt class="xref py py-meth docutils literal"><span class="pre">monomials()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.monomials()
[y*z, z^2, x, y]
</pre></div>
</div>
<p>These monomials are listed in descending order using the term ordering specified when the ring was constructed.</p>
<p id="index-83">To access a list of <em>coefficients</em> we use the <tt class="xref py py-meth docutils literal"><span class="pre">coefficients()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.coefficients()
[-1, 8, -1/2, -1]
</pre></div>
</div>
<p id="index-84">The list of coefficients is provided in the same order as the monomial listing computed earlier. This means that we can create a list of <em>terms</em> of our polynomial by  <a class="reference external" href="http://docs.python.org/library/functions.html#zip" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">zip()</span></tt></a>-ing up the two lists.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: [ a*b for a,b in zip(p.coefficients(),p.monomials())]
[-y*z, 8*z^2, -1/2*x, -y]
</pre></div>
</div>
<p id="index-85">Often you want to compute information pertaining to the <em>largest</em>, or <em>leading</em>, term. We can compute the <em>lead coefficient</em>, <em>leading monomial</em>, and the <em>lead term</em> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.lc()
-1
sage:
sage: p.lm()
y*z
sage: p.lt()
-y*z
</pre></div>
</div>
<p id="index-86">We can also compute the polynomial&#8217;s <em>total degree</em> using the <tt class="xref py py-meth docutils literal"><span class="pre">total_degree()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.total_degree()
2
</pre></div>
</div>
<p id="index-87">The exponents of each variable in each term, once again specified in descending order, is computed using the <tt class="xref py py-meth docutils literal"><span class="pre">exponents()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.exponents()
[(0, 1, 1), (0, 0, 2), (1, 0, 0), (0, 1, 0)]
</pre></div>
</div>
<p>and the exponent of the lead term is computed by chaining together two of the methods just presented.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.lm().exponents()
[(0, 1, 1)]
</pre></div>
</div>
<p id="index-88">To change the term ordering we must reconstruct both the ring itself and all of the polynomials with which we were working. The following code constructs a multivariate polynomial ring in <img class="math" src="_images/math/033c2beaaa126434950aabf4fee0b6e4cd0e0039.png" alt="x,y,"/> and <img class="math" src="_images/math/84d7271dd9e78c1e05d6c3c6ecb60309ef7dfc73.png" alt="z"/> using the <em>lexicographic</em> monomial ordering.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x,y,z&gt; = PolynomialRing(QQ,3,order=&#39;lex&#39;)
sage: p = -1/2*x - y*z - y + 8*z^2; p
-1/2*x - y*z - y + 8*z^2
</pre></div>
</div>
<p>Once the term order  changes, all of the methods discussed earlier, even how Sage displays the polynomial, take this into account.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p.lm()
x
sage: p.lc()
-1/2
sage: p.lt()
-1/2*x
sage: p.monomials()
[x, y*z, y, z^2]
</pre></div>
</div>
<p>Note that the order in which the indeterminates are listed affects the
monomial ordering. In the example above we have the  lexicographic
ordering, with <img class="math" src="_images/math/da91afa4ecbe5693c5c86a8acca9493826856f47.png" alt="x&gt;y&gt;z"/>.   We may redefine the ring to use the lexicographic order <img class="math" src="_images/math/6e0bed84d8faca705eebb4f60739e3734d420193.png" alt="z&gt;y&gt;x"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;z,y,x&gt; = PolynomialRing(QQ,3,order=&#39;lex&#39;)
sage:  p = -1/2*x - y*z - y + 8*z^2
sage: p
8*z^2 - z*y - y - 1/2*x
sage: p.lm()
z^2
sage: p.lc()
8
sage: p.lt()
8*z^2
</pre></div>
</div>
<p>Note again how all of the methods automatically take the new ordering into account.</p>
<p id="index-89">Finally we can <em>reduce</em> a polynomial modulo a list of polynomials using the <tt class="xref py py-meth docutils literal"><span class="pre">mod()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: r = -x^2 + 1/58*x*y - y + 1/2*z^2
sage: r.mod([p,q])
-238657765/29696*y^2 + 83193/14848*y*z^2 + 68345/14848*y - 1/1024*z^4 + 255/512*z^2 - 1/1024
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Use Sage to find out which of the following polynomials with rational coefficients are irreducible.<ol class="loweralpha">
<li><img class="math" src="_images/math/837d453d70d89ae670caf6f7ec4b917cb209a27c.png" alt="3 y^{4} - \frac{1}{2} y^{2} - \frac{1}{2} y - \frac{1}{2}"/></li>
<li><img class="math" src="_images/math/dd4ba9dc6803fdfaffa1a989b347ce188442258b.png" alt="2 y^{4} - y^{2} - y"/></li>
<li><img class="math" src="_images/math/01535c2eaa6e6ad8c206e025b434d8c013b7bcde.png" alt="\frac{1}{5} y^{5} - \frac{1}{3} y^{4} + y^{3} - \frac{17}{2} y^{2} - 21 y"/></li>
<li><img class="math" src="_images/math/4b4ceecd268bd0fe4d6b6451bb427692df72e8c9.png" alt="y^{3} + \frac{1}{4} y^{2} - 6 y + \frac{1}{8}"/></li>
<li><img class="math" src="_images/math/30841692f24c24ccfafebe17476d52f4a1ed237e.png" alt="3 y^{7} + y^{6} + \frac{9}{2} y^{4} - y^{3} + y^{2} - \frac{1}{2} y"/></li>
</ol>
</li>
<li>Factor all of the polynomials over <img class="math" src="_images/math/26cbe427b76bd14e825eb224773e28f116048644.png" alt="\mathbb{Z}[x]"/>.<ol class="loweralpha">
<li><img class="math" src="_images/math/ca9863a94de1d610802aa57da0ce18743a42712a.png" alt="-x^{10} + 4x^{9} - x^{8} + x^{7} - x^{6} + 2x^{3} + x^{2} - 1"/></li>
<li><img class="math" src="_images/math/2602b50e220e0f90754811d3cb3d42be0cbc0463.png" alt="x^{5} + 2x^{4} + x^{3} + 3x^{2} - 3"/></li>
<li><img class="math" src="_images/math/c80ef7811718c580a8251001b025e6feaa09b243.png" alt="x^{4} + x^{3} - x^{2} - x"/></li>
<li><img class="math" src="_images/math/0a3cf23739f1b033ef2467e80e7f38b03cd1510f.png" alt="2x^{8} - 5x^{7} - 3x^{6} + 15x^{5} - 3x^{4} - 15x^{3} + 7x^{2} + 5x - 3"/></li>
<li><img class="math" src="_images/math/3ad4897d29456b089a3531f79c722cbc06d3c0b9.png" alt="6x^{6} - x^{5} - 8x^{4} - x^{3} + 3x^{2} + x"/></li>
</ol>
</li>
<li>Compute all of the <em>roots</em> and of the following polynomials defined over <img class="math" src="_images/math/95a79bc032c993290f76c99e08d64e4ff395bb63.png" alt="\mathbb{Z}_7"/>. Compare this list to their factorizations.<ol class="loweralpha">
<li><img class="math" src="_images/math/73189c9565c0c6d6fb79df0de5d90ffd5b9d94e6.png" alt="2 x^{7} + 3 x^{6} + 6 x^{5} + 4 x^{4} + x^{3} + 5 x^{2} + 2 x + 5"/></li>
<li><img class="math" src="_images/math/8ff72928be27bda3dcd72f7a23fcdc9d7a89d085.png" alt="3 x^{3} + x^{2} + 2 x + 1"/></li>
<li><img class="math" src="_images/math/4290d6dcafec2c96b1f063e77dcafcb0cc93a385.png" alt="3 x^{8} + 5 x^{7} + 5 x^{5} + x^{3} + 2 x^{2} + 6 x"/></li>
<li><img class="math" src="_images/math/16fa284a82ce19f6b9e3befb8ac9bd6ff79b9e93.png" alt="x^{5} + 2 x^{4} + x^{3} + 2 x^{2} + 2 x + 1"/></li>
<li><img class="math" src="_images/math/0b4a20322f15207c24f9b241e690df4ac6f11c3c.png" alt="2 x^{10} + 2 x^{8} + 5 x^{6} + x^{5} + 3 x^{4} + 5 x^{3} + 2 x^{2} + 6 x + 5"/></li>
</ol>
</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="ideals-and-quotients">
<span id="id13"></span><h3>Ideals and Quotients<a class="headerlink" href="#ideals-and-quotients" title="Permalink to this headline">¶</a></h3>
<p>In this section we will construct and do common computations with ideals and quotient rings.</p>
<div class="section" id="ideals">
<span id="index-90"></span><span id="id14"></span><h4>Ideals<a class="headerlink" href="#ideals" title="Permalink to this headline">¶</a></h4>
<p>Once a ring is constructed and a list of generating elements have been selected, the ideal generated by this list is constructed by using the <tt class="docutils literal"><span class="pre">*</span></tt> operator.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt; = PolynomialRing(QQ)
sage: I = [2*x^2 + 8*x - 10, 10*x - 10]*R; I
Principal ideal (x - 1) of Univariate Polynomial Ring in x over Rational Field
sage: J = [ x^2 + 1, x^3 + x ]*R; J
Principal ideal (x^2 + 1) of Univariate Polynomial Ring in x over Rational Field
sage: K = [ x^2 + 1, x - 2]*R; K
Principal ideal (1) of Univariate Polynomial Ring in x over Rational Field
</pre></div>
</div>
<p id="index-91">Sage automatically reduces the set of generators. This can be seen by using the <tt class="xref py py-meth docutils literal"><span class="pre">gens()</span></tt> method which returns the list of the ideal&#8217;s generating elements.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: I.gens()
(x - 1,)
sage: J.gens()
(x^2 + 1,)
sage: K.gens()
(1,)
</pre></div>
</div>
<p id="index-92">Ideal membership can be determined by using the <tt class="docutils literal"><span class="pre">in</span></tt> conditional.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R(x-1) in I
True
sage: R(x) in I
False
sage: R(2) in J
False
sage: R(2) in K
True
</pre></div>
</div>
<p id="index-93">You can determine some properties of the ideal by using the corresponding <tt class="docutils literal"><span class="pre">is_</span></tt> methods. For example, to determine weather the
ideals are <em>prime</em>, <em>principal</em>, or <em>idempotent</em> we enter the following:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: J.is_prime()
True
sage: K.is_prime()
False
sage: I.is_idempotent()
False
sage: K.is_principal()
True
</pre></div>
</div>
</div>
<div class="section" id="ideals-in-multivarate-polynomial-rings">
<h4>Ideals in Multivarate Polynomial Rings<a class="headerlink" href="#ideals-in-multivarate-polynomial-rings" title="Permalink to this headline">¶</a></h4>
<p>To construct an ideal within a multivariate polynomial ring, we must
first construct the Polynomial ring with a term ordering and a collection of polynomials that will generate the ideal.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x,y,z&gt; = PolynomialRing(QQ,3,order=&#39;lex&#39;)
sage: p = -1/2*x - y*z - y + 8*z^2
sage: q = -32*x + 2869*y - z^2 - 1
</pre></div>
</div>
<p id="index-94">The ideal is constructed in the same manner as before.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: I = [p,q]*R
sage: I
Ideal (-1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1) of Multivariate Polynomial Ring in x, y, z over Rational Field
</pre></div>
</div>
<p id="index-95">When the ring is a multivariate polynomial, we can compute a special list of generators for <tt class="docutils literal"><span class="pre">I</span></tt>, called a <em>groebner_basis</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: I.groebner_basis()
[x - 2869/32*y + 1/32*z^2 + 1/32, y*z + 2933/64*y - 513/64*z^2 - 1/64]
</pre></div>
</div>
<p>There are different algorithms for computing a Groebner basis. We can change the algorithm by supplying an optional argument to the <tt class="xref py py-meth docutils literal"><span class="pre">groebner_basis()</span></tt> command. The following commands compute a Groebner basis using the Buchberger algorithm while showing the intermediate results. Very useful for teaching!</p>
<div class="highlight-python"><div class="highlight"><pre>sage: set_verbose(3)
sage: I.groebner_basis(&#39;toy:buchberger&#39;)
(-32*x + 2869*y - z^2 - 1, -1/2*x - y*z - y + 8*z^2) =&gt; -2*y*z - 2933/32*y + 513/32*z^2 + 1/32
G: set([-2*y*z - 2933/32*y + 513/32*z^2 + 1/32, -1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1])
(-1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1) =&gt; 0
G: set([-2*y*z - 2933/32*y + 513/32*z^2 + 1/32, -1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1])
(-1/2*x - y*z - y + 8*z^2, -2*y*z - 2933/32*y + 513/32*z^2 + 1/32) =&gt; 0
G: set([-2*y*z - 2933/32*y + 513/32*z^2 + 1/32, -1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1])
(-32*x + 2869*y - z^2 - 1, -2*y*z - 2933/32*y + 513/32*z^2 + 1/32) =&gt; 0
G: set([-2*y*z - 2933/32*y + 513/32*z^2 + 1/32, -1/2*x - y*z - y + 8*z^2, -32*x + 2869*y - z^2 - 1])
3 reductions to zero.
[x + 2*y*z + 2*y - 16*z^2, x - 2869/32*y + 1/32*z^2 + 1/32, y*z + 2933/64*y - 513/64*z^2 - 1/64]
</pre></div>
</div>
<p id="index-96">We can compute the various <em>elimination ideals</em> by using the <tt class="xref py py-meth docutils literal"><span class="pre">elimination_ideal()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: I.elimination_ideal([x])
Ideal (64*y*z + 2933*y - 513*z^2 - 1) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([x,y])
Ideal (0) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([x,z])
Ideal (0) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([x])
Ideal (64*y*z + 2933*y - 513*z^2 - 1) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([y])
Ideal (64*x*z + 2933*x + 2*z^3 - 45902*z^2 + 2*z + 2) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([z])
Ideal (263169*x^2 + 128*x*y^2 - 47095452*x*y + 16416*x - 11476*y^3 + 2106993608*y^2 - 1468864*y + 256) of Multivariate Polynomial Ring in x, y, z over Rational Field
sage: I.elimination_ideal([x,y])
Ideal (0) of Multivariate Polynomial Ring in x, y, z over Rational Field
</pre></div>
</div>
</div>
</div>
<div class="section" id="quotient-rings">
<span id="index-97"></span><span id="id15"></span><h3>Quotient Rings<a class="headerlink" href="#quotient-rings" title="Permalink to this headline">¶</a></h3>
<p id="index-98">To construct the <em>quotient ring</em> of a ring with an ideal we use the
<tt class="xref py py-meth docutils literal"><span class="pre">quotient()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R = ZZ
sage: I = R*[5]
sage: I
Principal ideal (5) of Integer Ring
sage: Q = R.quotient(I)
sage: Q
Ring of integers modulo 5
</pre></div>
</div>
<p>To  preform arithmetic in the quotient ring, we must first <em>coerce</em> elements into this universe. For more on why we do this see <a class="reference internal" href="sageprog.html#universes-and-coercion"><em>Universes and Coercion</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Q(10)
0
sage: Q(12)
2
sage: Q(10) + Q(12)
2
sage: Q(10 + 12)
2
</pre></div>
</div>
<p id="index-99">When working with quotients of polynomial rings it is a good idea to give
the indeterminate a new name.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;x&gt; = PolynomialRing(ZZ)
sage: parent(x)
Univariate Polynomial Ring in x over Integer Ring
sage: I = R.ideal(x^2 + 1)
sage: Q.&lt;a&gt; = R.quotient(I)
sage: parent(a)
Univariate Quotient Polynomial Ring in a over Integer Ring with modulus x^2 + 1
sage: a^2
-1
sage: x^2
x^2
</pre></div>
</div>
<p>Then we can do arithmetic in this quotient ring without having to
explicitly coerce all of our elements.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: 15*a^2 + 20*a + 1
20*a - 14
sage: (15 + a)*(14 - a)
-a + 211
</pre></div>
</div>
</div>
<div class="section" id="properties-of-rings">
<span id="rings-properties-and-tests"></span><span id="index-100"></span><h3>Properties of Rings<a class="headerlink" href="#properties-of-rings" title="Permalink to this headline">¶</a></h3>
<p id="index-101">You can check some of the properties of the rings which have been constructed. For example, to check whether a ring is an <em>integral domain</em> or a <em>field</em> we use the <tt class="xref py py-meth docutils literal"><span class="pre">is_integral_domain()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">is_field()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: QQ.is_field()
True
sage: ZZ.is_integral_domain()
True
sage: ZZ.is_field()
False
sage: R=Integers(15)
sage: R.is_integral_domain()
False
sage: S=Integers(17)
sage: S.is_field()
True
</pre></div>
</div>
<p>These properties are often determined instantaneously since they are built into the definitions of the rings and not calculated on the fly.</p>
<p id="index-102">For a complete listing of properties that are built into a ring, you can use Sage&#8217;s built in <em>tab-completion</em>. For example, to see all of the properties which can be determined for the rational numbers we type <tt class="docutils literal"><span class="pre">QQ.is</span></tt> then the tab key. What we get is a list of all of the properties that we can compute.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: QQ.is[TAB]
QQ.is_absolute           QQ.is_finite             QQ.is_ring
QQ.is_atomic_repr        QQ.is_integral_domain    QQ.is_subring
QQ.is_commutative        QQ.is_integrally_closed  QQ.is_zero
QQ.is_exact              QQ.is_noetherian
QQ.is_field              QQ.is_prime_field
</pre></div>
</div>
<p id="index-103">The <em>characteristic</em> of the ring can be computed using the ring&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">characteristic()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: QQ.characteristic()
0
sage: R=Integers(43)
sage: R.characteristic()
43
sage: F.&lt;a&gt; = FiniteField(9)
sage: F.characteristic()
3
sage: ZZ.characteristic()
0
</pre></div>
</div>
</div>
<div class="section" id="mini-topic-multivariate-polynomial-division-algorithm">
<span id="mv-division-algorithm"></span><span id="index-104"></span><h3>Mini-Topic: Multivariate Polynomial Division Algorithm<a class="headerlink" href="#mini-topic-multivariate-polynomial-division-algorithm" title="Permalink to this headline">¶</a></h3>
<p>In this section we will use Sage to construct a <em>division</em> algorithm for multivariate polynomials. Specifically, for a given polynomial <img class="math" src="_images/math/0001d02b63ede2fe3219e05a7cd09c82ae6298b6.png" alt="f"/> (the dividend) and a sequence of polynomials <img class="math" src="_images/math/1bafe4400374257e0e12e5056adc4a482d369002.png" alt="f_1, f_2, \ldots, f_k"/> (the divisors) we want to compute a sequence of quotients <img class="math" src="_images/math/4ed9d58799e54bf5b63fcdc0096e28e2e81e2fe0.png" alt="a_1, a_2,\ldots, a_k"/> and a remainder polynomial <img class="math" src="_images/math/2ede365ad144ab396916ec60458da03860803078.png" alt="r"/> so that</p>
<div class="math">
<p><img src="_images/math/d8b5ea2785f6c0dcd2ac4cc79846d600a63ab9a2.png" alt="f = \sum_{i=1}^{i=k} a_i \cdot f_i + r"/></p>
</div><p>where no terms of <img class="math" src="_images/math/2ede365ad144ab396916ec60458da03860803078.png" alt="r"/> are divisible by any of the leading terms of <img class="math" src="_images/math/f3e8f82a52bdd47c816d880bdbe685ecfc88160b.png" alt="f_i"/>.</p>
<p id="index-105">The first thing that we will do is to construct the base field for the polynomial ring and determine how many variables we want for the polynomial ring. In this case, lets define a two variable polynomial ring over the finite field <img class="math" src="_images/math/591f903dce5fea610dab078af467b84bdc5d8963.png" alt="\mathbb{F}_{2}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K = GF(2)
sage: n = 2
</pre></div>
</div>
<p>Next we will construct the polynomial ring.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: P.&lt;x,y&gt; = PolynomialRing(F,2,order=&quot;lex&quot;)
</pre></div>
</div>
<p>Since we are working with more than one variable we must tell Sage how to order the terms, in this case we selected a <em>lexicographic</em> ordering. The default term ordering is <em>degree reverse lexicographic</em>, where the <em>total degree</em> is used first to determine the order of the monomials, then a <em>reverse lexicographic</em> order is used to break ties. Other options for monomial orderings are <cite>deglex</cite> (degree lexicographic) or you can define a <em>block</em> ordering by using the <tt class="xref py py-func docutils literal"><span class="pre">TermOrder()</span></tt> command. You can read more on monomial orderings on-line on <a class="reference external" href="http://http://en.wikipedia.org/wiki/Monomial_order">Wikipedia</a> and on <a class="reference external" href="http://mathworld.wolfram.com/MonomialOrder.html">MathWorld</a>,  or the book <a class="reference internal" href="#cox2007" id="id16">[Cox2007]</a> .</p>
<table class="docutils citation" frame="void" id="cox2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[Cox2007]</a></td><td>Cox, David and Little, John and O&#8217;Shea, Donald, <em>Ideals, varieties, and algorithms.</em> Springer 2007</td></tr>
</tbody>
</table>
<p>Now we will begin our division algorithm. The first thing we will do is define a function which determines whether two monomial <em>divide</em> each other.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">does_divide</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">m1</span><span class="o">.</span><span class="n">degrees</span><span class="p">())</span> <span class="o">-</span> <span class="n">vector</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span><span class="n">m2</span><span class="o">.</span><span class="n">degrees</span><span class="p">())):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
           <span class="k">return</span> <span class="bp">False</span>
<span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>Then we will define a sequence of polynomials which we will use to reduce our <em>dividend</em>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F  = [x^2 + x,  y^2 + y]
</pre></div>
</div>
<p>Next we will define the polynomial which will be reduced.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: f = x^3* y^2
</pre></div>
</div>
<p>Now we will define the list of quotients and the remainder and initialize them to <img class="math" src="_images/math/74c081db590f3d35421c1f6b9afd4cdda36ee210.png" alt="0"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A =  [P(0) for  i in range(0,len(F)) ]
sage: r  = P(0)
</pre></div>
</div>
<p>Now because we alter f through the algorithm we will create a copy of it so that we can keep the value of <img class="math" src="_images/math/0001d02b63ede2fe3219e05a7cd09c82ae6298b6.png" alt="f"/> for later to verify the algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p = f
</pre></div>
</div>
<p>Now we are ready to define the main loop of our algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre>while p != P(0):
    i = 0
    div_occurred = False
    while (i &lt; len(F) and div_occurred == False):
        print A,p,r
        if does_divide(p.lm(), F[i]):
            q = P(p.lm()/F[i].lm())
            A[i] = A[i] + q
            p = p - q*F[i]
            div_occurred = True
        else:
            i = i + 1
    if div_occurred == False:
        r = r + p.lm()
        p = p - p.lm()

print A, p, r
</pre></div>
</div>
</div>
</div>
<div class="section" id="fields">
<span id="id17"></span><h2>Fields<a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h2>
<span class="target" id="number-fields"></span><div class="section" id="index-106">
<span id="id18"></span><h3>Number Fields<a class="headerlink" href="#index-106" title="Permalink to this headline">¶</a></h3>
<p>We  create a number field by specifying an irreducible polynomial and a name for the root of that polynomial.  We may use the indeterminate <img class="math" src="_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/>, which is already defined in sage.  We can also create a polynomial ring over the rationals and use the indeterminate for that polynomial ring.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: P.&lt;t&gt; = PolynomialRing(QQ)
sage: K.&lt;a&gt; = NumberField(t^3-2)
sage: K
Number Field in a with defining polynomial t^3 - 2
sage: K.polynomial()
t^3 - 2
</pre></div>
</div>
<p>A &#8220;random element&#8221; may be constructed producing an element with degree at most 2 (one less than the degree of the defining polynomial).
The options <tt class="xref py py-meth docutils literal"><span class="pre">num_bound()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">dem_bound()</span></tt> may be used to bound the numerator or denominator.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K.random_element()
-5/14*a^2 + a - 3
sage: K.random_element()
-2*a
sage: K.random_element(num_bound= 2)
-a^2 + 1
</pre></div>
</div>
<p>Every irrational element will have a minimal polynomial of degree 3.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a.minpoly()
 x^3 - 2
 sage: (a^2-3*a).minpoly()
 x^3 + 18*x + 50
</pre></div>
</div>
<p>We can test isomorphism of fields.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K.&lt;a&gt;= NumberField(t^3-2)
sage: L.&lt;b&gt; = NumberField(t^3-6*t-6)
sage: K.is_isomorphic(L)
True
</pre></div>
</div>
<p>The number of real embeddings and the number of pairs of complex embeddings are given by  the signature of the field.  The embeddings into the real field, <tt class="xref py py-meth docutils literal"><span class="pre">RR()</span></tt> , or complex field <tt class="xref py py-meth docutils literal"><span class="pre">CC()</span></tt>  may also be constructed.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K.signature()
(1, 1)
sage: K.real_embeddings()
[
Ring morphism:
  From: Number Field in a with defining polynomial t^3 - 2
  To:   Real Field with 53 bits of precision
  Defn: a |--&gt; 1.25992104989487
]
sage: K.complex_embeddings()
[
Ring morphism:
  From: Number Field in a with defining polynomial t^3 - 2
  To:   Complex Field with 53 bits of precision
  Defn: a |--&gt; -0.629960524947437 - 1.09112363597172*I,
Ring morphism:
  From: Number Field in a with defining polynomial t^3 - 2
  To:   Complex Field with 53 bits of precision
  Defn: a |--&gt; -0.629960524947437 + 1.09112363597172*I,
Ring morphism:
  From: Number Field in a with defining polynomial t^3 - 2
  To:   Complex Field with 53 bits of precision
  Defn: a |--&gt; 1.25992104989487
]
sage: phi1, phi2, phi3 = K.complex_embeddings()
sage: phi1(a)
-0.629960524947437 - 1.09112363597172*I
sage: phi2(a)
-0.629960524947437 + 1.09112363597172*I
sage: phi3(a^2+3*a+5)
10.3671642016528
</pre></div>
</div>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">Galois</span> <span class="pre">group()</span></tt> method computes the  Galois group of the Galois closure, not of the field itself.  When the Galois group is not cyclic, as in the second example, you need to name one of the generators.  The generators may also be accessed as shown below.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = L.galois_group()
sage: G.gens()
[(1,2,3)]
sage: H.&lt;g&gt;= K.galois_group()
sage: H.gens()
[(1,2)(3,4)(5,6), (1,4,6)(2,5,3)]
sage: H.0
(1,2)(3,4)(5,6)
sage: H.1
(1,4,6)(2,5,3)
</pre></div>
</div>
<p>The Galois closure of K.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: L.&lt;b&gt; = K.galois_closure()
sage: L
Number Field in b with defining polynomial t^6 + 40*t^3 + 1372
</pre></div>
</div>
<div class="section" id="field-extensions">
<h4>Field Extensions<a class="headerlink" href="#field-extensions" title="Permalink to this headline">¶</a></h4>
<p>Now let&#8217;s construct field extensions, which may be done in a few different ways.   The methods   <tt class="xref py py-meth docutils literal"><span class="pre">absolute_()</span></tt> refer to the prime field <img class="math" src="_images/math/7460925db718da589258ca5ba22dd1eed447a065.png" alt="\mathbb{Q}"/>, while the methods <tt class="xref py py-meth docutils literal"><span class="pre">relative_()</span></tt>   refer to a field extension as constructed, which may be relative to some intermediate field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: P.&lt;t&gt; = PolynomialRing(QQ)
sage: K.&lt;a&gt; = NumberField(t^3-2)
sage: L.&lt;b&gt; = NumberField(t^3-a)
sage: L.relative_degree(); L.relative_polynomial()
3
t^3 - a
sage: L.base_field()
Number Field in a with defining polynomial t^3 - 2
sage: L.absolute_degree(); L.absolute_polynomial()
9
x^9 - 2
sage: L.gens()
(b, a)
</pre></div>
</div>
<p>We may also create the compositum of several fields defined by a list of polynomials over the rationals.  We must specify a root for each polynomial.
Sage creates a sequence of 3 fields in the following example, starting at the far right in the list.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: M.&lt;a,b,c&gt; = NumberField([t^3-2, t^2-3, t^3-5])
sage: M
Number Field in a with defining polynomial t^3 - 2 over its base field
sage: M.relative_degree()
3
sage: M.absolute_degree()
18
sage: d = M.absolute_generator(); d
a - b + c
sage: d.minpoly()
x^3 + (3*b - 3*c)*x^2 + (-6*c*b + 3*c^2 + 9)*x + (3*c^2 + 3)*b - 9*c - 7
sage: d.absolute_minpoly()
x^18 - 27*x^16 - 42*x^15 + 324*x^14 + 378*x^13 - 2073*x^12 + 1134*x^11 - 6588*x^10 - 23870*x^9 + 88695*x^8 + 79002*x^7 - 147369*x^6 - 1454922*x^5 + 431190*x^4 + 164892*x^3 + 2486700*x^2 - 1271592*x + 579268
</pre></div>
</div>
<p>The next example computes the Galois closure of <tt class="xref py py-meth docutils literal"><span class="pre">K()</span></tt>  and asks for the roots of unity.   The generator for <tt class="xref py py-meth docutils literal"><span class="pre">L()</span></tt> is something that sage computes, so it may have a complicated minimum polynomial, as we see.  We know that <tt class="xref py py-meth docutils literal"><span class="pre">L()</span></tt>  contains cube roots of unity, so let&#8217;s verify it.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: K.&lt;a&gt; = NumberField(t^3-2)
sage: L.&lt;b&gt; = K.galois_closure()
sage: b.minpoly()
x^6 + 40*x^3 + 1372
sage: units= L.roots_of_unity(); units
[1/36*b^3 + 19/18, 1/36*b^3 + 1/18, -1, -1/36*b^3 - 19/18, -1/36*b^3 - 1/18, 1]
sage: len(units)
6
sage: [u^3 for u in units]
[-1, 1, -1, 1, -1, 1]
</pre></div>
</div>
</div>
<div class="section" id="special-number-fields">
<h4>Special Number Fields<a class="headerlink" href="#special-number-fields" title="Permalink to this headline">¶</a></h4>
<p>There are two classes of number fields with special properties that you can construct directly.  For a <em>quadratic field extension</em> simply specify a square free integer.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F.&lt;a&gt; = QuadraticField(17)
sage: a^2
17
sage: (7*a-3).minpoly()
x^2 + 6*x - 824
</pre></div>
</div>
<p>A <em>cyclotomic field</em> is created by indentifying its primitive root of unity.</p>
<p>CyclotomicField()</p>
<p>QuadraticField()</p>
</div>
</div>
<div class="section" id="finite-fields">
<span id="id19"></span><h3>Finite Fields<a class="headerlink" href="#finite-fields" title="Permalink to this headline">¶</a></h3>
<p id="index-107">In a prior section we constructed rings of integers modulo <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>. We know that when <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> is a prime number the <em>ring</em> <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> is actually a <em>field</em>. Sage will allow us to construct this same object as either a ring or a field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R = Integers(7)
sage: F7 = GF(7)
sage: R, F7
(Ring of integers modulo 7, Finite Field of size 7)
</pre></div>
</div>
<p>To take advantage of the extra stucture it is best to use the command <tt class="xref py py-func docutils literal"><span class="pre">GF()</span></tt> (or equivalently, <tt class="xref py py-func docutils literal"><span class="pre">FiniteField()</span></tt>) to construct this object.  As with modular rings we have to coerece integers into the field in order to do arithemetic in the field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F7(4 + 3)
0
sage: F7(2*3)
6
sage: F7(3*7)
0
sage: F7(3/2)
5
</pre></div>
</div>
<p>We can use Sage to construct any <em>finite field</em>.  Recall that a finite field is always of order <img class="math" src="_images/math/81333f5491cf56cdbbccdb9db49224329dc79038.png" alt="n = p^k"/> where <img class="math" src="_images/math/3eca8557203e86160952e1c0f735f7417f3285b1.png" alt="p"/> is a prime number. To construct the field of order <img class="math" src="_images/math/679e9d8c1000321242d57065347c004b9e282418.png" alt="25 = 5^2"/> we input the following command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F25.&lt;a&gt; = GF(25)
</pre></div>
</div>
<p id="index-108">Recall that the finite field of order <img class="math" src="_images/math/ab56b0b1efd8489518794bc98ac6ab10c53bc138.png" alt="5^2"/> can be thought of a an <em>extension</em> of <img class="math" src="_images/math/bf473a390714974c97f0f62ea665ac30d021b76d.png" alt="\mathbb{Z}_{5}"/> using a root of a polynomial of degree <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/>. The <tt class="docutils literal"><span class="pre">a</span></tt> that you specified is a root of this polynomial. There are different polynomials that can be used to construct this extension and Sage chooses one for you. You can see the polynomial chosen by using the, aptly named, <tt class="xref py py-meth docutils literal"><span class="pre">polynomial()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p = F25.polynomial();
sage: p
a^2 + 4*a + 2
</pre></div>
</div>
<p>We can verify that <tt class="docutils literal"><span class="pre">a</span></tt> satisfies this polynomial.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: a^2 + 4*a + 2
0
</pre></div>
</div>
<p>It should be noted that <tt class="docutils literal"><span class="pre">a</span></tt> already lives in the field and no special coercion is necessary to do arithmetic using <tt class="docutils literal"><span class="pre">a</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: parent(a)
Finite Field in a of size 5^2
sage: a^2
a + 3
sage: a*(a^2 + 1)
3
</pre></div>
</div>
<p>But if we are using only integers we must coerce the arithmetic into the field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: 3+4
7
sage: parent(3+4)
Integer Ring
sage: F25(3 + 4)
2
sage: parent(F25(3+4))
Finite Field in a of size 5^2
</pre></div>
</div>
<p id="index-109">Sometimes we would like to specify the polynomial used to construct out extension. to do so we just need to add the <em>modulus</em> option to our field constructor.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F25.&lt;a&gt; = GF(25, modulus=x^2 + x + 1)
sage: a^2 + a + 1
0
sage: a^2
4*a + 4
</pre></div>
</div>
<p>Remember that the modulus must be a polynomial which is <em>irreducible</em> over <img class="math" src="_images/math/c472392dec9847eeab3151a273bb6d6301350233.png" alt="\mathbb{F}_{5}[x]"/>. Many times we would like for the modulus to not just be irreducible, but to be <a class="reference external" href="http://en.wikipedia.org/wiki/Primitive_polynomial_(field_theory)">primitive</a>. Next we will construct all of the primitive polynomials of degree <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/>. The following example uses <a class="reference internal" href="#polynomial-rings"><em>Polynomial Rings</em></a> and <a class="reference internal" href="sageprog.html#list-comprehensions"><em>List Comprehensions (Loops in Lists)</em></a>. First thing that we will do is construct a list of all monic polynomials over <img class="math" src="_images/math/d7c54a885b39bd0d0808ba2bac662fa224d5dbc3.png" alt="\mathrm{GF}(5)"/></p>
<div class="highlight-python"><div class="highlight"><pre>sage: F5 = GF(5)
sage: P.&lt;x&gt; = PolynomialRing(F, &#39;x&#39;)
sage: AP = [ a0 + a1*x + a2*x^2 for (a0,a1) in F^3]
sage: AP
[x^2, x^2 + 1, x^2 + 2, x^2 + 3, x^2 + 4, x^2 + x, x^2 + x + 1, x^2 + x + 2, x^2 + x + 3, x^2 + x + 4, x^2 + 2*x, x^2 + 2*x + 1, x^2 + 2*x + 2, x^2 + 2*x + 3, x^2 + 2*x + 4, x^2 + 3*x, x^2 + 3*x + 1, x^2 + 3*x + 2, x^2 + 3*x + 3, x^2 + 3*x + 4, x^2 + 4*x, x^2 + 4*x + 1, x^2 + 4*x + 2, x^2 + 4*x + 3, x^2 + 4*x + 4]
</pre></div>
</div>
<p id="index-110">Next we will <em>filter</em> out the primitive polynomials out of this list.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: PR = [ p for p in AP if p.is_primitive() ]
sage: PR
[x^2 + x + 2, x^2 + 2*x + 3, x^2 + 3*x + 3, x^2 + 4*x + 2]
</pre></div>
</div>
<p id="index-111">If we wanted all of the <em>irreducible</em> polynomials we would only change the last command slightly.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: IR = [ p for p in AP if p.is_irreducible() ]
sage: IR
[x^2 + 2, x^2 + 3, x^2 + x + 1, x^2 + x + 2, x^2 + 2*x + 3, x^2 + 2*x + 4, x^2 + 3*x + 3, x^2 + 3*x + 4, x^2 + 4*x + 1, x^2 + 4*x + 2]
</pre></div>
</div>
<p>It should be noted that the above code will only work if the polynomials are over <em>finite</em> rings or fields.</p>
<p><strong>Exercises:</strong></p>
<ol class="arabic simple">
<li>Compute the list of all <em>primitive polynomials</em> of degree 3 over <img class="math" src="_images/math/fefcc9bad5c62dbb1ee8d7c0eccc8af6fc67be7c.png" alt="GF(5)"/>.</li>
<li>Compute the number of <em>primitive elements</em>  in <img class="math" src="_images/math/e259d3efce42a05d2ff6d6e09198e6cf33b55c1a.png" alt="GF(125)"/>.</li>
<li>Explain the relationship between the  number of primitive polynomials and the number of primitive elemens in the previous exercises.</li>
</ol>
</div>
<div class="section" id="function-fields">
<span id="id20"></span><h3>Function Fields<a class="headerlink" href="#function-fields" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="coding-theory">
<span id="index-112"></span><span id="id21"></span><h2>Coding Theory<a class="headerlink" href="#coding-theory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linear-codes">
<span id="index-113"></span><span id="id22"></span><h3>Linear Codes<a class="headerlink" href="#linear-codes" title="Permalink to this headline">¶</a></h3>
<p>A <em>linear code</em> is just a finite-dimensional vector space commonly defined over a finite field. To construct a linear code in Sage we first define a finite field and a matrix over this field whose range will define this vector space.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F = GF(2)
sage: G = matrix(F, [(0,1,0,1,0),(0,1,1,1,0),(0,0,1,0,1),(0,1,0,0,1)]); G
[0 1 0 1 0]
[0 1 1 1 0]
[0 0 1 0 1]
[0 1 0 0 1]
</pre></div>
</div>
<p id="index-114">The code itself is constructed by the <tt class="xref py py-func docutils literal"><span class="pre">LinearCode()</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = LinearCode(G); C
Linear code of length 5, dimension 4 over Finite Field of size 2
</pre></div>
</div>
<p id="index-115">While the <em>length</em> and <em>dimension</em> of the code are displayed in the object&#8217;s <em>description</em>, you can also obtain these properties at anytime using the code&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">length()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">dimension()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.length()
5
sage: C.dimension()
4
</pre></div>
</div>
<p id="index-116">Given two code words, we can compute their <em>Hamming Weight</em> and <em>Distance</em> both by using the <tt class="xref py py-func docutils literal"><span class="pre">hamming_weight()</span></tt> function.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: w1 = vector(F, (0,1,0,1,0)); w1
(0, 1, 0, 1, 0)
sage: hamming_weight(w1)
2
sage: w2 = vector(F, (0,1,1,0,1)); w2
(0, 1, 1, 0, 1)
sage: hamming_weight(w2)
3
sage: hamming_weight(w1 - w2)
3
</pre></div>
</div>
<p id="index-117">The <em>minimum distance</em> of <tt class="docutils literal"><span class="pre">C</span></tt> can be computed by using the <tt class="xref py py-meth docutils literal"><span class="pre">minimum_distance()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.minimum_distance()
1
</pre></div>
</div>
<p id="index-118">Sage can also compute the <em>distribution</em> of weights for the code.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.weight_distribution()
[1, 4, 6, 4, 1, 0]
</pre></div>
</div>
<p>Where the value listed at index <tt class="docutils literal"><span class="pre">i</span></tt> of the list, starting with zero and ending with the length of the code, is the number of codewords with that weight.</p>
<p id="index-119">Related to the weight distribution is the <em>weight enumerator</em> polynomial, which you compute using the code&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">weight_enumerator()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.weight_enumerator()
x^5 + 4*x^4*y + 6*x^3*y^2 + 4*x^2*y^3 + x*y^4
</pre></div>
</div>
<p id="index-120">The <em>generating</em> and <em>check</em> matrices are computed using the <tt class="xref py py-meth docutils literal"><span class="pre">gen_mat()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">check_mat()</span></tt> methods.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.gen_mat()
[0 1 0 1 0]
[0 1 1 1 0]
[0 0 1 0 1]
[0 1 0 0 1]
sage: C.check_mat()
[1 0 0 0 0]
</pre></div>
</div>
<p id="index-121">The <em>systematic</em> form of the generating matrix is computed using <tt class="xref py py-meth docutils literal"><span class="pre">gen_mat_systematic()</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.gen_mat_systematic()
[0 1 0 0 0]
[0 0 1 0 0]
[0 0 0 1 0]
[0 0 0 0 1]
</pre></div>
</div>
<p id="index-122">Sage can both <em>extend</em> and <em>puncture</em> our code. The <em>extended code</em> is computed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Cx = C.extended_code(); Cx
Linear code of length 6, dimension 4 over Finite Field of size 2
sage: Cx.gen_mat()
[0 1 0 1 0 0]
[0 1 1 1 0 1]
[0 0 1 0 1 0]
[0 1 0 0 1 0]
sage: Cx.check_mat()
[1 0 0 0 0 0]
[0 1 1 1 1 1]
</pre></div>
</div>
<p id="index-123">The <em>punctured</em> code is computed by supplying the code&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">punctured()</span></tt> method a list of coordinates in which to delete. The following commands construct the code that results when the 1st and 3rd coordinate from every code word in <tt class="docutils literal"><span class="pre">C</span></tt> are deleted. Note that unlike vectors, lists and matrices the 1st column is indexed by 1 and not 0 when puncturing a code.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Cp = C.punctured([1,3]); Cp
Linear code of length 3, dimension 2 over Finite Field of size 2
sage: Cp.gen_mat()
[0 1 0]
[0 0 1]
sage: Cp.check_mat()
[1 0 0]
</pre></div>
</div>
<p id="index-124">Sage can also compute the <em>dual</em> of <tt class="docutils literal"><span class="pre">C</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Cd = C.dual_code(); Cd
Linear code of length 5, dimension 1 over Finite Field of size 2
sage: Cd.gen_mat()
[1 0 0 0 0]
sage: Cd.check_mat()
[0 1 0 0 0]
[0 0 1 0 0]
[0 0 0 1 0]
[0 0 0 0 1]
</pre></div>
</div>
<p id="index-125">And finally Sage can <em>decode</em> a received vector. The following simulates a communications channel; We begin with a code word, introduce an error and then correct this error by <em>decoding</em> the received message.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: wrd = vector(F,(0,0,0,0,1))
sage: err = vector(F,(0,0,1,0,0))
sage: msg = wrd + err; msg
(0, 0, 1, 0, 1)
sage: C.decode(msg)
(0, 0, 0, 0, 1)
sage: C.decode(msg) == wrd
True
</pre></div>
</div>
<p>It should be noted that since the above code has a minimum distance of only 1 that decoding will not always produce the code word that you may have expected.</p>
<p>These are only some of the commands that Sage offers for computing and working with linear codes. There is much more information on the following web sites:</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ol class="last arabic simple">
<li><a class="reference external" href="http://www.sagemath.org/doc/constructions/linear_codes.html">http://www.sagemath.org/doc/constructions/linear_codes.html</a></li>
<li><a class="reference external" href="http://www.sagemath.org/doc/reference/sage/coding/linear_code.html">http://www.sagemath.org/doc/reference/sage/coding/linear_code.html</a></li>
</ol>
</div>
</div>
<div class="section" id="cyclic-codes">
<span id="index-126"></span><span id="id23"></span><h3>Cyclic Codes<a class="headerlink" href="#cyclic-codes" title="Permalink to this headline">¶</a></h3>
<p>To construct a cyclic code of length <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/> over <img class="math" src="_images/math/5943208c54bb31a62bf7d71a671b930b03f3bcee.png" alt="\mathbb{F}_2"/> we first need a <em>generating polynomial</em>, which can be any <em>irreducible</em> factor of <img class="math" src="_images/math/62ebac0f5f5d34a35ee07fba07bb2f5879fbfefe.png" alt="x^{3} - 1"/>. A list of irreducible factors is computed using the <tt class="xref py py-func docutils literal"><span class="pre">factor()</span></tt> command.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: P.&lt;x&gt; = PolynomialRing(GF(2),&#39;x&#39;)
sage: factor(x^3 -1 )
(x + 1) * (x^2 + x + 1)
</pre></div>
</div>
<p id="index-127">The output above tells you that there are 2 choices for non-trivial generating polynomials. The following commands will construct the code generated by <img class="math" src="_images/math/89b32fe9c797548684d31f3e5d3bed1b78e2b754.png" alt="g(x) = x + 1"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: g = x + 1
sage: C = CyclicCode(3,g)
sage: C.list()
[(0, 0, 0), (1, 0, 1), (0, 1, 1), (1, 1, 0)]
</pre></div>
</div>
<p>Cyclic codes are a special type of linear code. So the commands that you worked with in the prior section all work in the same way. For example, the generating matrix is computed, in the usual and systematic forms, as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>sage: G = C.gen_mat(); G
[1 1 0]
[0 1 1]
sage: Gs = C.gen_mat_systematic(); Gs
[1 0 1]
[0 1 1]
</pre></div>
</div>
<p>Just to verify that this is the generating matrix, and to practice working with matrices and vectors,  we will see if the image of <img class="math" src="_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/> spans the code.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: vector(GF(2),[0,0])*G
(0,0,0)
sage: vector(GF(2),[1,0])*G
(1, 1, 0)
sage: vector(GF(2),[1,1])*G
(1, 0, 1)
sage: vector(GF(2),[0,1])*G
(0, 1, 1)
</pre></div>
</div>
<p>Sage can also compute a <em>parity check</em> matrix of <img class="math" src="_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> using the code&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">check_mat()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H = C.check_mat()
[1 1 1]
</pre></div>
</div>
<p>Verifying that <tt class="docutils literal"><span class="pre">H</span></tt> is a <em>check matrix</em> for <img class="math" src="_images/math/2bcc65482aa8e15cd4c9e9f2542451fb4e971a91.png" alt="C"/> is straightforward.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: H*vector(GF(2),[0,1,1])
(0)
sage: H*vector(GF(2),[1,0,1])
(0)
sage: H*vector(GF(2),[1,0,0])
(1)
</pre></div>
</div>
<p>You can also compute the <em>dual code</em> and it&#8217;s generating and parity check matrices.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Cp = C.dual_code()
sage: Cp.gen_mat()
[1 1 1]
sage: Cp.check_mat()
[1 0 1]
[0 1 1]
</pre></div>
</div>
</div>
<div class="section" id="mini-topic-factoring">
<span id="mt-roots-of-unity"></span><h3>Mini-Topic: Factoring <img class="math" src="_images/math/e228758ed57713b7801c54c5e065ed9246a58bea.png" alt="x^n -1"/><a class="headerlink" href="#mini-topic-factoring" title="Permalink to this headline">¶</a></h3>
<p>The smallest field containing <img class="math" src="_images/math/16564b131d4936ee3ec944b075907069221e5278.png" alt="\mathbb{F}_{q}"/> and containing the roots of <img class="math" src="_images/math/c8ac586f614200d8ed5c2db74b7f2a08f691f22d.png" alt="x^n - 1"/> is <img class="math" src="_images/math/d6b25e0c74b3da01d2f22aa9536d37e639556d0d.png" alt="GF(q^t)"/> where <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> is the order of <img class="math" src="_images/math/23f1b45408e5b4130c0f940fcbfcec54492cbdcd.png" alt="q"/> in <img class="math" src="_images/math/9b54f312bfc6c34889682b5ee33580fc6c92d350.png" alt="\mathbb{Z} \bmod{n}"/>.</p>
<p>The factors of <img class="math" src="_images/math/c8ac586f614200d8ed5c2db74b7f2a08f691f22d.png" alt="x^n - 1"/> over <img class="math" src="_images/math/16564b131d4936ee3ec944b075907069221e5278.png" alt="\mathbb{F}_{q}"/> must all have degree dividing <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>.</p>
<p>Let us begin by first defining <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> and <img class="math" src="_images/math/23f1b45408e5b4130c0f940fcbfcec54492cbdcd.png" alt="q"/> and constructing the ambient rings.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: n = 19
sage: q = 2
sage: F = GF(2)
sage: P.&lt;x&gt; = PolynomialRing(F, &#39;x&#39;)
</pre></div>
</div>
<p id="index-128">Remembering that since we are constructing a finite field that <img class="math" src="_images/math/23f1b45408e5b4130c0f940fcbfcec54492cbdcd.png" alt="q"/> has to either be prime or a prime power. Now let us compute all of the irreducable factors of <img class="math" src="_images/math/21723f32b9398a856226e86d3192a51108340188.png" alt="x^{n} -1"/> over <img class="math" src="_images/math/16564b131d4936ee3ec944b075907069221e5278.png" alt="\mathbb{F}_{q}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A = factor(x^n-1); A
</pre></div>
</div>
<p id="index-129">Now to verify the facts about the degrees of the factors computed that was stated ealier. Compare the list above with the order of <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> in <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Integers(19)(2).multiplicative_order()
</pre></div>
</div>
<p>Remembering that since <img class="math" src="_images/math/64fcc87a202bcb33f99a404daabaa0a85757d581.png" alt="\mathbb{Z}_{n}"/> is a ring, we have to specify which type of <em>order</em> we want to compute, either <em>additive</em> or <em>multiplicative</em>.</p>
<p>Now let us repeat what we just did, but this time letting <img class="math" src="_images/math/13e2692f0fae7caee6cd150debdebe8744f91f7a.png" alt="q=2^2"/>. Changing <cite>q</cite> alone will not change the base field nor the polynomial ring. So we will have to re-construct everything using our new parameter.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: q = 4
sage: F.&lt;a&gt; = GF(4,&#39;a&#39;)
sage: P.&lt;x&gt; = PolynomialRing(F,&#39;x&#39;)
</pre></div>
</div>
<p>Now let us factor <img class="math" src="_images/math/c8ac586f614200d8ed5c2db74b7f2a08f691f22d.png" alt="x^n - 1"/> again. This time over a non-prime field.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A = factor(x^n-1); A
(x + 1) * (x^9 + a*x^8 + a*x^6 + a*x^5 + (a + 1)*x^4 + (a + 1)*x^3 + (a + 1)*x + 1) * (x^9 + (a + 1)*x^8 + (a + 1)*x^6 + (a + 1)*x^5 + a*x^4 + a*x^3 + a*x + 1)
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Try repeating the above for <img class="math" src="_images/math/c72bd561437171d02d9e816103fc7f9ecefe31fe.png" alt="F= \mathbb{F}_{8}"/>.</li>
<li>Compute the order of 2, 4, 8 mod 19. What are your observations?</li>
<li>Try other values of n and other fields.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mini-topic-idempotent-polynomials">
<span id="cyclic-codes-idempotents"></span><span id="index-130"></span><h3>Mini-Topic: Idempotent Polynomials<a class="headerlink" href="#mini-topic-idempotent-polynomials" title="Permalink to this headline">¶</a></h3>
<p>We&#8217;ll find the idempotent which is 1 modulo the ith factor of <img class="math" src="_images/math/e228758ed57713b7801c54c5e065ed9246a58bea.png" alt="x^n -1"/>. Continuing with <img class="math" src="_images/math/cb4d8fd39cb56938f730fe22719013426fd48a07.png" alt="\mathbb{F}_{4}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F.&lt;a&gt; = GF(4, &#39;a&#39;)
sage: P.&lt;x&gt; = PolynomialRing(F, &#39;x&#39;)
</pre></div>
</div>
<p id="index-131">Then we will create the quotient ring.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: R.&lt;y&gt; = P.quotient(x^19 - 1)
sage: A = factor(x^19 - 1); A
(x + 1) * (x^9 + a*x^8 + a*x^6 + a*x^5 + (a + 1)*x^4 + (a + 1)*x^3 + (a + 1)*x + 1) * (x^9 + (a + 1)*x^8 + (a + 1)*x^6 + (a + 1)*x^5 + a*x^4 + a*x^3 + a*x + 1)
</pre></div>
</div>
<p>Since the <tt class="xref py py-func docutils literal"><span class="pre">factor()</span></tt> command returns a list of polynomial factors and their multiplicities, which we do not need, we will strip those out.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: A = [p[0] for p in A]
</pre></div>
</div>
<p>Now we will just select one of these factors. The reader should also try different factors for themselves.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: p0 = A[2]
</pre></div>
</div>
<p id="index-132">Now we take the product of all of the other factors.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: ap = prod( [p for p in A if p != a])
x^10 + (a + 1)*x^9 + a*x^8 + a*x^7 + x^5 + (a + 1)*x^3 + (a + 1)*x^2 + a*x + 1
</pre></div>
</div>
<p id="index-133">Then compute the <tt class="xref py py-func docutils literal"><span class="pre">xgcd()</span></tt> of <cite>p0</cite> and <cite>ap</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: d, s, t = xgcd(p0, ap)
</pre></div>
</div>
<p>You should recall that <img class="math" src="_images/math/cefdd2d5f98541185d0c2ba8535865a7bb497869.png" alt="d = s \cdot p_0 + t* ap"/> is the extended gcd. You should check that <img class="math" src="_images/math/3b5f7601cb18ef34710556982b675085e5ac3c69.png" alt="s\cdot p_0 \equiv 1 \bmod{p}"/> for all <img class="math" src="_images/math/fad7ed33e127a99117d73331a1e4abf262026c86.png" alt="p \neq p_0"/> and <img class="math" src="_images/math/eaee36352a33e6604a9e64b417261bf10c844cf3.png" alt="s\cdot p_0 \equiv 0 \bmod{p_0}"/></p>
<div class="highlight-python"><div class="highlight"><pre>sage: s*p0 % A[1]
1
sage: s*p0 % A[2]
0
sage: s*p0 % A[0]
1
</pre></div>
</div>
<p>Now check that <img class="math" src="_images/math/f6f044a6cfea5827b50a0590f174c5a3e15823be.png" alt="t\cdot ap \equiv 0 \bmod{p}"/> for <img class="math" src="_images/math/fad7ed33e127a99117d73331a1e4abf262026c86.png" alt="p \neq p_0"/> and <img class="math" src="_images/math/90d6eb27a330467e159055a76cb5d1cf3fb570a2.png" alt="t \cdot ap \equiv 1 \bmod{p_0}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: t*ap % A[0]
0
sage: t*ap % A[1]
0
sage: t*ap % A[2]
1
</pre></div>
</div>
<p>Now we will check that the polynomial that we computed is an idempotent in <img class="math" src="_images/math/58095574ef1f2d1928acb6a729ea46b4a930ff41.png" alt="F\left[x\right]/\left&lt;x^n - 1 \right&gt;"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: f = R(bp*ap)
sage: f^2 == f
True
</pre></div>
</div>
<p id="index-134">Check the generating polynomial.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: gcd(b*p0, x^19-1)
x^9 + (a + 1)*x^8 + (a + 1)*x^6 + (a + 1)*x^5 + a*x^4 + a*x^3 + a*x + 1
sage: p0
x^9 + (a + 1)*x^8 + (a + 1)*x^6 + (a + 1)*x^5 + a*x^4 + a*x^3 + a*x + 1
</pre></div>
</div>
<p><strong>Exercises:</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>Find the idempoent element of <img class="math" src="_images/math/d3f74a2c715591a155692463e984cd3b1e50e5e3.png" alt="F\left[x\right]/\left&lt;x^n -1\right&gt;"/> For <img class="math" src="_images/math/5397f74e49a45d37cc3ecbd6903a73974c73c0ef.png" alt="q = 4"/> and <img class="math" src="_images/math/99a92d50648cd1491c9ef3a89a3c7e66d8891d4b.png" alt="n =3, 5, 11"/> and <img class="math" src="_images/math/69b2b4dbe02a4b8f6ad4185ebb232189f873c662.png" alt="17"/>.</li>
</ol>
</div></blockquote>
<p>For the reciprocal polynomials of idempotents, see Theorem 5 <a class="reference internal" href="#macwilliams1977" id="id24">[MacWilliams1977]</a> p. 219</p>
<table class="docutils citation" frame="void" id="macwilliams1977" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[MacWilliams1977]</a></td><td>MacWilliams, F. J. and Sloane, N. J. A., <em>The theory of error-correcting codes.</em> North-Holland Publishing Co. 1977</td></tr>
</tbody>
</table>
</div>
<div class="section" id="other-codes">
<h3>Other Codes<a class="headerlink" href="#other-codes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="hamming-codes">
<span id="index-135"></span><span id="id25"></span><h4>Hamming Codes<a class="headerlink" href="#hamming-codes" title="Permalink to this headline">¶</a></h4>
<p>A Hamming Code is a simple linear code which has the capability to detect up to 2 contiguous errors and correct for any single error.</p>
<p id="index-136">We will begin by constructing a binary Hamming code with 3 parity checks.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F = GF(2)
sage: C = HammingCode(3,F); C
Linear code of length 7, dimension 4 over Finite Field of size 2
</pre></div>
</div>
<p>Hamming codes always have a length, <img class="math" src="_images/math/9741fef99f2ece0b502709fe85e7fabed8da9cd6.png" alt="\vert \mathbb{F} \vert^r - 1"/> where <img class="math" src="_images/math/2ede365ad144ab396916ec60458da03860803078.png" alt="r"/> is the number of parity checks and <img class="math" src="_images/math/be3bcf8a19a928999cfb2020a2f51a96c93fbcb0.png" alt="\mathbb{F}"/> is the finite-field over which the code is defined. This is because the columns of it&#8217;s <em>parity check</em> matrix consists of all non-zero elements of <img class="math" src="_images/math/5e67ed605275e477daff9e490f97d182b0be5a4f.png" alt="\mathbb{F}^r"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.check_mat()
[1 0 1 0 1 0 1]
[0 1 1 0 0 1 1]
[0 0 0 1 1 1 1]
</pre></div>
</div>
<p>A Ternary Hamming Code is constructed by supplying a non-binary finite field as the base field. Here we will construct the ternary Hamming code over <img class="math" src="_images/math/9e2b80433466fa323457aaf84d6b0dd2e608d02e.png" alt="GF(2^3)"/> also with 3 parity checks.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C = HammingCode(3, F); C
Linear code of length 73, dimension 70 over Finite Field in a of size 2^3
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/Hamming_code">http://en.wikipedia.org/wiki/Hamming_code</a></p>
</div>
</div>
<div class="section" id="bch-codes">
<span id="index-137"></span><span id="id26"></span><h4>BCH Codes<a class="headerlink" href="#bch-codes" title="Permalink to this headline">¶</a></h4>
<p>BCH codes, or Bose-Chaudhuri-Hockenghem codes, are a special class of the cyclic codes with 3 required parameters, <img class="math" src="_images/math/987f70ac0736fc35d006e53e1f1d4245b3a529fb.png" alt="n, \delta, F"/> and one optional one <img class="math" src="_images/math/5e87bf41a96deddf6cb485ff530f153f2590e9cc.png" alt="b"/>. Here <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/> is the length of the code words, <img class="math" src="_images/math/b35a9439ad8c8657b1b1d792ad5c2d77a52c0aef.png" alt="\delta"/> is a parameter called the <em>designed distance</em> and <img class="math" src="_images/math/183421431fcc0a42e22f825a33dcc3c51607fa6e.png" alt="F"/> is a finite field of order <img class="math" src="_images/math/c4ee247a6ef5159eff0fd99047325d7369d15aa7.png" alt="q^{n}"/> where <img class="math" src="_images/math/3baab498f356bead46084ba668f911408c7a17ef.png" alt="gcd(n, q) = 1"/>.</p>
<p id="index-138">If <img class="math" src="_images/math/5e87bf41a96deddf6cb485ff530f153f2590e9cc.png" alt="b"/> is not provided then a default value of zero is used. For example, you construct construct a BCH code of length <img class="math" src="_images/math/c6a6bd4fd1ce090c8ab20626fe6266efc072e187.png" alt="n = 13"/> with <img class="math" src="_images/math/b8bf1fb4594e741930168b0e9ab9ed148506c376.png" alt="\delta = 5"/> over <img class="math" src="_images/math/49ff6598eeb6e436eff87163b212bfd21aadf2a3.png" alt="F = \mathrm{GF}(9)"/>.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: F.&lt;a&gt; = GF(3^2,&#39;a&#39;)
sage: C = BCHCode(13, 5, F)
sage: C
Linear code of length 13, dimension 6 over Finite Field in a of size 3^2
</pre></div>
</div>
<p>We can compute the code&#8217;s minimum distance using it&#8217;s <tt class="xref py py-meth docutils literal"><span class="pre">minimum_distance()</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.minimum_distance()
6
</pre></div>
</div>
<p>Since BCH codes are also linear, you can use Sage to compute the code&#8217;s generating and check matrices.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: C.gen_mat()
[2 2 1 2 0 0 1 1 0 0 0 0 0]
[0 2 2 1 2 0 0 1 1 0 0 0 0]
[0 0 2 2 1 2 0 0 1 1 0 0 0]
[0 0 0 2 2 1 2 0 0 1 1 0 0]
[0 0 0 0 2 2 1 2 0 0 1 1 0]
[0 0 0 0 0 2 2 1 2 0 0 1 1]
sage: C.check_mat()
[1 0 0 0 0 0 0 1 2 1 2 2 2]
[0 1 0 0 0 0 0 1 0 0 0 1 1]
[0 0 1 0 0 0 0 2 2 2 1 1 2]
[0 0 0 1 0 0 0 1 1 0 1 0 0]
[0 0 0 0 1 0 0 0 1 1 0 1 0]
[0 0 0 0 0 1 0 0 0 1 1 0 1]
[0 0 0 0 0 0 1 2 1 2 2 2 1]
</pre></div>
</div>
<p>We can also compute it&#8217;s <em>dual</em> code.</p>
<div class="highlight-python"><div class="highlight"><pre>sage: Cp = C.dual_code(); Cp
Linear code of length 13, dimension 7 over Finite Field in a of size 3^2
sage: Cp.gen_mat()
[1 0 0 0 0 0 0 1 2 1 2 2 2]
[0 1 0 0 0 0 0 1 0 0 0 1 1]
[0 0 1 0 0 0 0 2 2 2 1 1 2]
[0 0 0 1 0 0 0 1 1 0 1 0 0]
[0 0 0 0 1 0 0 0 1 1 0 1 0]
[0 0 0 0 0 1 0 0 0 1 1 0 1]
[0 0 0 0 0 0 1 2 1 2 2 2 1]
sage: Cp.check_mat()
[1 0 0 0 0 0 2 2 1 2 0 0 1]
[0 1 0 0 0 0 1 0 1 2 2 0 2]
[0 0 1 0 0 0 2 0 1 0 2 2 1]
[0 0 0 1 0 0 1 0 2 2 0 2 1]
[0 0 0 0 1 0 1 2 2 0 2 0 1]
[0 0 0 0 0 1 1 2 1 0 0 2 2]
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://en.wikipedia.org/wiki/BCH_code">http://en.wikipedia.org/wiki/BCH_code</a></p>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
    <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">

	  <h3><a href="index.html">Topics</a></h3>
	  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About this tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="sagecalc.html">Sage as a Calculator</a></li>
<li class="toctree-l1"><a class="reference internal" href="sageprog.html">Programming in Sage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Mathematical Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#integers-and-modular-arithmetic">Integers and Modular Arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integers-modulo">Integers Modulo <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/></a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving-congruences">Solving Congruences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mini-topic-euclidean-algorithm">Mini-Topic: Euclidean Algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#groups">Groups</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-groups">Symmetric  Groups</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#general-permutation-groups">General Permutation Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quotients-of-permutation-groups">Quotients of Permutation Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#permutation-group-homomorphisms">Permutation Group Homomorphisms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-groups">Matrix Groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abelian-groups">Abelian Groups</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#index-29">Linear Algebra</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vectors-and-matrices">Vectors and Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-arithmetic">Matrix Arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-38">Matrix Manipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-52">Vector and Matrix Spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mini-topic-the-jordan-canonical-form">Mini-Topic: The Jordan Canonical Form</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#index-63">Rings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#polynomial-rings">Polynomial Rings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multivariate-polynomial-rings">Multivariate Polynomial Rings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ideals-and-quotients">Ideals and Quotients</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ideals">Ideals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ideals-in-multivarate-polynomial-rings">Ideals in Multivarate Polynomial Rings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quotient-rings">Quotient Rings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#properties-of-rings">Properties of Rings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mini-topic-multivariate-polynomial-division-algorithm">Mini-Topic: Multivariate Polynomial Division Algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fields">Fields</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#index-106">Number Fields</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#field-extensions">Field Extensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#special-number-fields">Special Number Fields</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#finite-fields">Finite Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-fields">Function Fields</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coding-theory">Coding Theory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#linear-codes">Linear Codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cyclic-codes">Cyclic Codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mini-topic-factoring">Mini-Topic: Factoring <img class="math" src="_images/math/e228758ed57713b7801c54c5e065ed9246a58bea.png" alt="x^n -1"/></a></li>
<li class="toctree-l3"><a class="reference internal" href="#mini-topic-idempotent-polynomials">Mini-Topic: Idempotent Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-codes">Other Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hamming-codes">Hamming Codes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bch-codes">BCH Codes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

	  <h3>This Page</h3>
	  <ul class="this-page-menu">
	    <li><a href="_sources/mathstruct.txt"
	    rel="nofollow">Show Source</a></li>
	  </ul>
	<div id="searchbox" style="display: none">
	  <h3>Quick search</h3>
	  <form class="search" action="search.html" method="get">
	  <input type="text" name="q" size="18" />
	  <input type="submit" value="Go" />
	  <input type="hidden" name="check_keywords" value="yes" />
	  <input type="hidden" name="area" value="default" />
	  </form>
	</div>
	<script type="text/javascript">$('#searchbox').show(0);</script>
       </div>
    </div>

      <div class="clearer"></div>
    </div> 
<div class="related"> &nbsp; </div>

    <div class="footer">
        &copy; Copyright 2011, Michael O&#39;Sullivan,  David Monarres.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>